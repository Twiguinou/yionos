package glfw3;

public final class GLFW3
{private GLFW3() {}

    public static final int GLFW_NATIVE_CONTEXT_API = 221185;
    public static final int GLFW_GAMEPAD_BUTTON_LEFT_THUMB = 9;
    public static final int GLFW_KEY_F25 = 314;
    public static final int GLFW_KEY_KP_SUBTRACT = 333;
    public static final int GLFW_KEY_LEFT_SUPER = 343;
    public static final int GLFW_LOSE_CONTEXT_ON_RESET = 200706;
    public static final int GLFW_RED_BITS = 135169;
    public static final int GLFW_KEY_F6 = 295;
    public static final int GLFW_KEY_F5 = 294;
    public static final int GLFW_KEY_F8 = 297;
    public static final int GLFW_KEY_F7 = 296;
    public static final int GLFW_KEY_LEFT_BRACKET = 91;
    public static final int GLFW_KEY_F9 = 298;
    public static final int GLFW_KEY_GRAVE_ACCENT = 96;
    public static final int GLFW_KEY_F10 = 299;
    public static final int GLFW_KEY_F11 = 300;
    public static final int GLFW_KEY_F12 = 301;
    public static final int GLFW_KEY_F13 = 302;
    public static final int GLFW_KEY_F2 = 291;
    public static final int GLFW_KEY_F1 = 290;
    public static final int GLFW_KEY_F4 = 293;
    public static final int GLFW_KEY_F3 = 292;
    public static final int GLFW_GAMEPAD_BUTTON_START = 7;
    public static final int GLFW_KEY_F21 = 310;
    public static final int GLFW_KEY_F22 = 311;
    public static final int GLFW_KEY_F23 = 312;
    public static final int GLFW_KEY_F24 = 313;
    public static final int GLFW_KEY_F20 = 309;
    public static final int GLFW_KEY_F18 = 307;
    public static final int GLFW_KEY_F19 = 308;
    public static final int GLFW_KEY_F14 = 303;
    public static final int GLFW_KEY_F15 = 304;
    public static final int GLFW_KEY_F16 = 305;
    public static final int GLFW_KEY_F17 = 306;
    public static final int GLFW_KEY_COMMA = 44;
    public static final int GLFW_CONTEXT_VERSION_MAJOR = 139266;
    public static final int GLFW_GAMEPAD_AXIS_RIGHT_Y = 3;
    public static final int GLFW_GAMEPAD_AXIS_RIGHT_X = 2;
    public static final int GLFW_CURSOR_NORMAL = 212993;
    public static final int GLFW_RELEASE_BEHAVIOR_NONE = 217090;
    public static final int GLFW_KEY_PAGE_UP = 266;
    public static final int GLFW_KEY_RIGHT_CONTROL = 345;
    public static final int GLFW_OPENGL_DEBUG_CONTEXT = 139271;
    public static final int GLFW_ALPHA_BITS = 135172;
    public static final int GLFW_KEY_LEFT_CONTROL = 341;
    public static final int GLFW_PLATFORM_ERROR = 65544;
    public static final int GLFW_KEY_KP_EQUAL = 336;
    public static final int GLFW_GAMEPAD_BUTTON_RIGHT_BUMPER = 5;
    public static final int GLFW_VISIBLE = 131076;
    public static final int GLFW_KEY_KP_MULTIPLY = 332;
    public static final int GLFW_OSMESA_CONTEXT_API = 221187;
    public static final int GLFW_KEY_KP_0 = 320;
    public static final int GLFW_MOD_NUM_LOCK = 32;
    public static final int GLFW_STICKY_MOUSE_BUTTONS = 208899;
    public static final int GLFW_KEY_KP_ENTER = 335;
    public static final int GLFW_KEY_SCROLL_LOCK = 281;
    public static final int GLFW_KEY_LEFT = 263;
    public static final int GLFW_GAMEPAD_AXIS_RIGHT_TRIGGER = 5;
    public static final int GLFW_HOVERED = 131083;
    public static final int GLFW_CONTEXT_NO_ERROR = 139274;
    public static final int GLFW_WAYLAND_LIBDECOR = 339969;
    public static final int GLFW_KEY_KP_9 = 329;
    public static final int GLFW_KEY_KP_3 = 323;
    public static final int GLFW_KEY_KP_4 = 324;
    public static final int GLFW_KEY_KP_1 = 321;
    public static final int GLFW_KEY_KP_2 = 322;
    public static final int GLFW_KEY_KP_7 = 327;
    public static final int GLFW_KEY_KP_8 = 328;
    public static final int GLFW_ICONIFIED = 131074;
    public static final int GLFW_KEY_KP_5 = 325;
    public static final int GLFW_KEY_KP_6 = 326;
    public static final int GLFW_KEY_PERIOD = 46;
    public static final int GLFW_TRANSPARENT_FRAMEBUFFER = 131082;
    public static final int GLFW_AUTO_ICONIFY = 131078;
    public static final int GLFW_HAT_RIGHT = 2;
    public static final int GLFW_GREEN_BITS = 135170;
    public static final int GLFW_NO_RESET_NOTIFICATION = 200705;
    public static final int GLFW_KEY_APOSTROPHE = 39;
    public static final int GLFW_KEY_BACKSPACE = 259;
    public static final int GLFW_KEY_PAUSE = 284;
    public static final int GLFW_OPENGL_CORE_PROFILE = 204801;
    public static final int GLFW_CURSOR_DISABLED = 212995;
    public static final int GLFW_ANY_RELEASE_BEHAVIOR = 0;
    public static final int GLFW_KEY_DOWN = 264;
    public static final int GLFW_HAT_LEFT = 8;
    public static final int GLFW_COCOA_CHDIR_RESOURCES = 331777;
    public static final int GLFW_JOYSTICK_12 = 11;
    public static final int GLFW_JOYSTICK_11 = 10;
    public static final int GLFW_JOYSTICK_10 = 9;
    public static final int GLFW_JOYSTICK_16 = 15;
    public static final int GLFW_CONTEXT_VERSION_MINOR = 139267;
    public static final int GLFW_JOYSTICK_15 = 14;
    public static final int GLFW_JOYSTICK_14 = 13;
    public static final int GLFW_JOYSTICK_13 = 12;
    public static final int GLFW_INVALID_VALUE = 65540;
    public static final int GLFW_KEY_BACKSLASH = 92;
    public static final int GLFW_STENCIL_BITS = 135174;
    public static final int GLFW_ACCUM_GREEN_BITS = 135176;
    public static final int GLFW_OPENGL_ANY_PROFILE = 0;
    public static final int GLFW_ACCUM_BLUE_BITS = 135177;
    public static final int GLFW_KEY_HOME = 268;
    public static final int GLFW_ACCUM_RED_BITS = 135175;
    public static final int GLFW_RESIZABLE = 131075;
    public static final int GLFW_NO_API = 0;
    public static final int GLFW_GAMEPAD_BUTTON_DPAD_DOWN = 13;
    public static final int GLFW_CONTEXT_REVISION = 139268;
    public static final int GLFW_CONTEXT_RELEASE_BEHAVIOR = 139273;
    public static final int GLFW_INVALID_ENUM = 65539;
    public static final int GLFW_KEY_MENU = 348;
    public static final int GLFW_REPEAT = 2;
    public static final int GLFW_HAT_UP = 1;
    public static final int GLFW_MOD_CAPS_LOCK = 16;
    public static final int GLFW_GAMEPAD_BUTTON_RIGHT_THUMB = 10;
    public static final int GLFW_EGL_CONTEXT_API = 221186;
    public static final int GLFW_KEY_NUM_LOCK = 282;
    public static final int GLFW_OUT_OF_MEMORY = 65541;
    public static final int GLFW_NO_CURRENT_CONTEXT = 65538;
    public static final int GLFW_OPENGL_PROFILE = 139272;
    public static final int GLFW_FALSE = 0;
    public static final int GLFW_VERSION_MINOR = 3;
    public static final int GLFW_CONTEXT_ROBUSTNESS = 139269;
    public static final int GLFW_CENTER_CURSOR = 131081;
    public static final int GLFW_BLUE_BITS = 135171;
    public static final int GLFW_KEY_WORLD_1 = 161;
    public static final int GLFW_KEY_WORLD_2 = 162;
    public static final int GLFW_CONTEXT_CREATION_API = 139275;
    public static final int GLFW_DOUBLEBUFFER = 135184;
    public static final int GLFW_GAMEPAD_BUTTON_DPAD_RIGHT = 12;
    public static final int GLFW_CURSOR_HIDDEN = 212994;
    public static final int GLFW_KEY_RIGHT_SHIFT = 344;
    public static final int GLFW_ARROW_CURSOR = 221185;
    public static final int GLFW_NO_ERROR = 0;
    public static final int GLFW_KEY_EQUAL = 61;
    public static final int GLFW_KEY_LEFT_ALT = 342;
    public static final int GLFW_NO_WINDOW_CONTEXT = 65546;
    public static final int GLFW_KEY_PAGE_DOWN = 267;
    public static final int GLFW_INCLUDE_VULKAN = 1;
    public static final int GLFW_RAW_MOUSE_MOTION = 208901;
    public static final int GLFW_CLIENT_API = 139265;
    public static final int GLFW_KEY_PRINT_SCREEN = 283;
    public static final int GLFW_COCOA_RETINA_FRAMEBUFFER = 143361;
    public static final int GLFW_AUX_BUFFERS = 135179;
    public static final int GLFW_RELEASE = 0;
    public static final int GLFW_GAMEPAD_BUTTON_BACK = 6;
    public static final int GLFW_JOYSTICK_1 = 0;
    public static final int GLFW_JOYSTICK_7 = 6;
    public static final int GLFW_JOYSTICK_6 = 5;
    public static final int GLFW_JOYSTICK_9 = 8;
    public static final int GLFW_JOYSTICK_8 = 7;
    public static final int GLFW_JOYSTICK_3 = 2;
    public static final int GLFW_JOYSTICK_2 = 1;
    public static final int GLFW_JOYSTICK_5 = 4;
    public static final int GLFW_JOYSTICK_4 = 3;
    public static final int GLFW_HAT_CENTERED = 0;
    public static final int GLFW_KEY_ENTER = 257;
    public static final int GLFW_CONNECTED = 262145;
    public static final int GLFW_KEY_RIGHT_ALT = 346;
    public static final int GLFW_RELEASE_BEHAVIOR_FLUSH = 217089;
    public static final int GLFW_MOD_CONTROL = 2;
    public static final int GLFW_WAYLAND_DISABLE_LIBDECOR = 229378;
    public static final int GLFW_KEY_MINUS = 45;
    public static final int GLFW_ACCUM_ALPHA_BITS = 135178;
    public static final int GLFW_WAYLAND_PREFER_LIBDECOR = 229377;
    public static final int GLFW_KEY_LEFT_SHIFT = 340;
    public static final int GLFW_KEY_ESCAPE = 256;
    public static final int GLFW_TRUE = 1;
    public static final int GLFW_SAMPLES = 135181;
    public static final int GLFW_CURSOR = 208897;
    public static final int GLFW_MOD_SUPER = 8;
    public static final int GLFW_FORMAT_UNAVAILABLE = 65545;
    public static final int GLFW_KEY_KP_DECIMAL = 330;
    public static final int GLFW_GAMEPAD_BUTTON_LEFT_BUMPER = 4;
    public static final int GLFW_VERSION_MAJOR = 3;
    public static final int GLFW_KEY_DELETE = 261;
    public static final int GLFW_GAMEPAD_BUTTON_X = 2;
    public static final int GLFW_GAMEPAD_BUTTON_Y = 3;
    public static final int GLFW_KEY_Z = 90;
    public static final int GLFW_KEY_Y = 89;
    public static final int GLFW_KEY_V = 86;
    public static final int GLFW_KEY_U = 85;
    public static final int GLFW_KEY_X = 88;
    public static final int GLFW_KEY_W = 87;
    public static final int GLFW_KEY_R = 82;
    public static final int GLFW_KEY_Q = 81;
    public static final int GLFW_KEY_T = 84;
    public static final int GLFW_KEY_S = 83;
    public static final int GLFW_KEY_N = 78;
    public static final int GLFW_KEY_M = 77;
    public static final int GLFW_KEY_P = 80;
    public static final int GLFW_KEY_O = 79;
    public static final int GLFW_KEY_J = 74;
    public static final int GLFW_KEY_I = 73;
    public static final int GLFW_KEY_L = 76;
    public static final int GLFW_KEY_K = 75;
    public static final int GLFW_MAXIMIZED = 131080;
    public static final int GLFW_IBEAM_CURSOR = 221186;
    public static final int GLFW_GAMEPAD_BUTTON_B = 1;
    public static final int GLFW_X11_CLASS_NAME = 147457;
    public static final int GLFW_GAMEPAD_BUTTON_A = 0;
    public static final int GLFW_OPENGL_COMPAT_PROFILE = 204802;
    public static final int GLFW_GAMEPAD_AXIS_LEFT_X = 0;
    public static final int GLFW_MOD_SHIFT = 1;
    public static final int GLFW_GAMEPAD_BUTTON_DPAD_UP = 11;
    public static final int GLFW_GAMEPAD_AXIS_LEFT_Y = 1;
    public static final int GLFW_KEY_F = 70;
    public static final int GLFW_KEY_E = 69;
    public static final int GLFW_KEY_H = 72;
    public static final int GLFW_KEY_G = 71;
    public static final int GLFW_KEY_B = 66;
    public static final int GLFW_KEY_A = 65;
    public static final int GLFW_KEY_D = 68;
    public static final int GLFW_KEY_C = 67;
    public static final int GLFW_MOD_ALT = 4;
    public static final int GLFW_KEY_9 = 57;
    public static final int GLFW_KEY_6 = 54;
    public static final int GLFW_COCOA_FRAME_NAME = 143362;
    public static final int GLFW_KEY_5 = 53;
    public static final int GLFW_KEY_8 = 56;
    public static final int GLFW_KEY_7 = 55;
    public static final int GLFW_KEY_2 = 50;
    public static final int GLFW_KEY_1 = 49;
    public static final int GLFW_KEY_4 = 52;
    public static final int GLFW_KEY_3 = 51;
    public static final int GLFW_KEY_0 = 48;
    public static final int GLFW_CROSSHAIR_CURSOR = 221187;
    public static final int GLFW_NOT_INITIALIZED = 65537;
    public static final int GLFW_PRESS = 1;
    public static final int GLFW_HAND_CURSOR = 221188;
    public static final int GLFW_OPENGL_FORWARD_COMPAT = 139270;
    public static final int GLFW_DISCONNECTED = 262146;
    public static final int GLFW_VRESIZE_CURSOR = 221190;
    public static final int GLFW_KEY_UP = 265;
    public static final int GLFW_X11_INSTANCE_NAME = 147458;
    public static final int GLFW_COCOA_GRAPHICS_SWITCHING = 143363;
    public static final int GLFW_STEREO = 135180;
    public static final int GLFW_SCALE_TO_MONITOR = 139276;
    public static final int GLFW_DECORATED = 131077;
    public static final int GLFW_MOUSE_BUTTON_1 = 0;
    public static final int GLFW_MOUSE_BUTTON_6 = 5;
    public static final int GLFW_MOUSE_BUTTON_7 = 6;
    public static final int GLFW_MOUSE_BUTTON_8 = 7;
    public static final int GLFW_MOUSE_BUTTON_2 = 1;
    public static final int GLFW_MOUSE_BUTTON_3 = 2;
    public static final int GLFW_MOUSE_BUTTON_4 = 3;
    public static final int GLFW_MOUSE_BUTTON_5 = 4;
    public static final int GLFW_COCOA_MENUBAR = 331778;
    public static final int GLFW_KEY_RIGHT = 262;
    public static final int GLFW_SRGB_CAPABLE = 135182;
    public static final int GLFW_KEY_TAB = 258;
    public static final int GLFW_OPENGL_API = 196609;
    public static final int GLFW_FOCUS_ON_SHOW = 131084;
    public static final int GLFW_KEY_KP_ADD = 334;
    public static final int GLFW_GAMEPAD_BUTTON_DPAD_LEFT = 14;
    public static final int GLFW_FOCUSED = 131073;
    public static final int GLFW_KEY_RIGHT_SUPER = 347;
    public static final int GLFW_OPENGL_ES_API = 196610;
    public static final int GLFW_KEY_KP_DIVIDE = 331;
    public static final int GLFW_GAMEPAD_AXIS_LEFT_TRIGGER = 4;
    public static final int GLFW_HRESIZE_CURSOR = 221189;
    public static final int GLFW_STICKY_KEYS = 208898;
    public static final int GLFW_KEY_INSERT = 260;
    public static final int GLFW_LOCK_KEY_MODS = 208900;
    public static final int GLFW_VERSION_REVISION = 9;
    public static final int GLFW_KEY_SLASH = 47;
    public static final int GLFW_DEPTH_BITS = 135173;
    public static final int GLFW_VERSION_UNAVAILABLE = 65543;
    public static final int GLFW_KEY_CAPS_LOCK = 280;
    public static final int GLFW_NO_ROBUSTNESS = 0;
    public static final int GLFW_REFRESH_RATE = 135183;
    public static final int GLFW_API_UNAVAILABLE = 65542;
    public static final int GLFW_KEY_RIGHT_BRACKET = 93;
    public static final int GLFW_KEY_END = 269;
    public static final int GLFW_GAMEPAD_BUTTON_GUIDE = 8;
    public static final int GLFW_KEY_SEMICOLON = 59;
    public static final int GLFW_FLOATING = 131079;
    public static final int GLFW_KEY_SPACE = 32;
    public static final int GLFW_JOYSTICK_HAT_BUTTONS = 327681;
    public static final int GLFW_HAT_DOWN = 4;

    public static final java.lang.foreign.Linker gSystemLinker;
    public static final java.lang.foreign.SymbolLookup gLibLookup;

    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwInit;
    public static final java.lang.invoke.MethodHandle MTD$glfwInit;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwTerminate;
    public static final java.lang.invoke.MethodHandle MTD$glfwTerminate;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwInitHint;
    public static final java.lang.invoke.MethodHandle MTD$glfwInitHint;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetVersion;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetVersion;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetVersionString;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetVersionString;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetError;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetError;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetErrorCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetErrorCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetMonitors;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetMonitors;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetPrimaryMonitor;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetPrimaryMonitor;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetMonitorPos;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetMonitorPos;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetMonitorWorkarea;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetMonitorWorkarea;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetMonitorPhysicalSize;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetMonitorPhysicalSize;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetMonitorContentScale;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetMonitorContentScale;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetMonitorName;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetMonitorName;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetMonitorUserPointer;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetMonitorUserPointer;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetMonitorUserPointer;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetMonitorUserPointer;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetMonitorCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetMonitorCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetVideoModes;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetVideoModes;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetVideoMode;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetVideoMode;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetGamma;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetGamma;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetGammaRamp;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetGammaRamp;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetGammaRamp;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetGammaRamp;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwDefaultWindowHints;
    public static final java.lang.invoke.MethodHandle MTD$glfwDefaultWindowHints;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwWindowHint;
    public static final java.lang.invoke.MethodHandle MTD$glfwWindowHint;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwWindowHintString;
    public static final java.lang.invoke.MethodHandle MTD$glfwWindowHintString;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwCreateWindow;
    public static final java.lang.invoke.MethodHandle MTD$glfwCreateWindow;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwDestroyWindow;
    public static final java.lang.invoke.MethodHandle MTD$glfwDestroyWindow;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwWindowShouldClose;
    public static final java.lang.invoke.MethodHandle MTD$glfwWindowShouldClose;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetWindowShouldClose;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetWindowShouldClose;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetWindowTitle;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetWindowTitle;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetWindowIcon;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetWindowIcon;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetWindowPos;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetWindowPos;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetWindowPos;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetWindowPos;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetWindowSize;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetWindowSize;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetWindowSizeLimits;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetWindowSizeLimits;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetWindowAspectRatio;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetWindowAspectRatio;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetWindowSize;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetWindowSize;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetFramebufferSize;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetFramebufferSize;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetWindowFrameSize;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetWindowFrameSize;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetWindowContentScale;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetWindowContentScale;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetWindowOpacity;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetWindowOpacity;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetWindowOpacity;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetWindowOpacity;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwIconifyWindow;
    public static final java.lang.invoke.MethodHandle MTD$glfwIconifyWindow;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwRestoreWindow;
    public static final java.lang.invoke.MethodHandle MTD$glfwRestoreWindow;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwMaximizeWindow;
    public static final java.lang.invoke.MethodHandle MTD$glfwMaximizeWindow;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwShowWindow;
    public static final java.lang.invoke.MethodHandle MTD$glfwShowWindow;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwHideWindow;
    public static final java.lang.invoke.MethodHandle MTD$glfwHideWindow;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwFocusWindow;
    public static final java.lang.invoke.MethodHandle MTD$glfwFocusWindow;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwRequestWindowAttention;
    public static final java.lang.invoke.MethodHandle MTD$glfwRequestWindowAttention;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetWindowMonitor;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetWindowMonitor;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetWindowMonitor;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetWindowMonitor;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetWindowAttrib;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetWindowAttrib;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetWindowAttrib;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetWindowAttrib;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetWindowUserPointer;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetWindowUserPointer;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetWindowUserPointer;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetWindowUserPointer;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetWindowPosCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetWindowPosCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetWindowSizeCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetWindowSizeCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetWindowCloseCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetWindowCloseCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetWindowRefreshCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetWindowRefreshCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetWindowFocusCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetWindowFocusCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetWindowIconifyCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetWindowIconifyCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetWindowMaximizeCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetWindowMaximizeCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetFramebufferSizeCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetFramebufferSizeCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetWindowContentScaleCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetWindowContentScaleCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwPollEvents;
    public static final java.lang.invoke.MethodHandle MTD$glfwPollEvents;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwWaitEvents;
    public static final java.lang.invoke.MethodHandle MTD$glfwWaitEvents;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwWaitEventsTimeout;
    public static final java.lang.invoke.MethodHandle MTD$glfwWaitEventsTimeout;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwPostEmptyEvent;
    public static final java.lang.invoke.MethodHandle MTD$glfwPostEmptyEvent;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetInputMode;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetInputMode;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetInputMode;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetInputMode;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwRawMouseMotionSupported;
    public static final java.lang.invoke.MethodHandle MTD$glfwRawMouseMotionSupported;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetKeyName;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetKeyName;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetKeyScancode;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetKeyScancode;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetKey;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetKey;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetMouseButton;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetMouseButton;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetCursorPos;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetCursorPos;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetCursorPos;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetCursorPos;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwCreateCursor;
    public static final java.lang.invoke.MethodHandle MTD$glfwCreateCursor;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwCreateStandardCursor;
    public static final java.lang.invoke.MethodHandle MTD$glfwCreateStandardCursor;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwDestroyCursor;
    public static final java.lang.invoke.MethodHandle MTD$glfwDestroyCursor;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetCursor;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetCursor;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetKeyCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetKeyCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetCharCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetCharCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetCharModsCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetCharModsCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetMouseButtonCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetMouseButtonCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetCursorPosCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetCursorPosCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetCursorEnterCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetCursorEnterCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetScrollCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetScrollCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetDropCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetDropCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwJoystickPresent;
    public static final java.lang.invoke.MethodHandle MTD$glfwJoystickPresent;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetJoystickAxes;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetJoystickAxes;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetJoystickButtons;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetJoystickButtons;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetJoystickHats;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetJoystickHats;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetJoystickName;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetJoystickName;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetJoystickGUID;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetJoystickGUID;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetJoystickUserPointer;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetJoystickUserPointer;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetJoystickUserPointer;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetJoystickUserPointer;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwJoystickIsGamepad;
    public static final java.lang.invoke.MethodHandle MTD$glfwJoystickIsGamepad;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetJoystickCallback;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetJoystickCallback;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwUpdateGamepadMappings;
    public static final java.lang.invoke.MethodHandle MTD$glfwUpdateGamepadMappings;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetGamepadName;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetGamepadName;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetGamepadState;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetGamepadState;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetClipboardString;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetClipboardString;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetClipboardString;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetClipboardString;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetTime;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetTime;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSetTime;
    public static final java.lang.invoke.MethodHandle MTD$glfwSetTime;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetTimerValue;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetTimerValue;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetTimerFrequency;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetTimerFrequency;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwMakeContextCurrent;
    public static final java.lang.invoke.MethodHandle MTD$glfwMakeContextCurrent;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetCurrentContext;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetCurrentContext;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSwapBuffers;
    public static final java.lang.invoke.MethodHandle MTD$glfwSwapBuffers;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwSwapInterval;
    public static final java.lang.invoke.MethodHandle MTD$glfwSwapInterval;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwExtensionSupported;
    public static final java.lang.invoke.MethodHandle MTD$glfwExtensionSupported;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetProcAddress;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetProcAddress;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwVulkanSupported;
    public static final java.lang.invoke.MethodHandle MTD$glfwVulkanSupported;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetRequiredInstanceExtensions;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetRequiredInstanceExtensions;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetInstanceProcAddress;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetInstanceProcAddress;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwGetPhysicalDevicePresentationSupport;
    public static final java.lang.invoke.MethodHandle MTD$glfwGetPhysicalDevicePresentationSupport;
    public static final java.lang.foreign.MemorySegment MTD_ADDRESS$glfwCreateWindowSurface;
    public static final java.lang.invoke.MethodHandle MTD$glfwCreateWindowSurface;

    /*! @brief Initializes the GLFW library.
     *
     *  This function initializes the GLFW library.  Before most GLFW functions can
     *  be used, GLFW must be initialized, and before an application terminates GLFW
     *  should be terminated in order to free any resources allocated during or
     *  after initialization.
     *
     *  If this function fails, it calls @ref glfwTerminate before returning.  If it
     *  succeeds, you should call @ref glfwTerminate before the application exits.
     *
     *  Additional calls to this function after successful initialization but before
     *  termination will return `GLFW_TRUE` immediately.
     *
     *  @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_PLATFORM_ERROR.
     *
     *  @remark @macos This function will change the current directory of the
     *  application to the `Contents/Resources` subdirectory of the application's
     *  bundle, if present.  This can be disabled with the @ref
     *  GLFW_COCOA_CHDIR_RESOURCES init hint.
     *
     *  @remark @x11 This function will set the `LC_CTYPE` category of the
     *  application locale according to the current environment if that category is
     *  still "C".  This is because the "C" locale breaks Unicode text input.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref intro_init
     *  @sa @ref glfwTerminate
     *
     *  @since Added in version 1.0.
     *
     *  @ingroup init
     */
    public static int glfwInit()
    {
        try {return (int)MTD$glfwInit.invokeExact();}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Terminates the GLFW library.
     *
     *  This function destroys all remaining windows and cursors, restores any
     *  modified gamma ramps and frees any other allocated resources.  Once this
     *  function is called, you must again call @ref glfwInit successfully before
     *  you will be able to use most GLFW functions.
     *
     *  If GLFW has been successfully initialized, this function should be called
     *  before the application exits.  If initialization fails, there is no need to
     *  call this function, as it is called by @ref glfwInit before it returns
     *  failure.
     *
     *  This function has no effect if GLFW is not initialized.
     *
     *  @errors Possible errors include @ref GLFW_PLATFORM_ERROR.
     *
     *  @remark This function may be called before @ref glfwInit.
     *
     *  @warning The contexts of any remaining windows must not be current on any
     *  other thread when this function is called.
     *
     *  @reentrancy This function must not be called from a callback.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref intro_init
     *  @sa @ref glfwInit
     *
     *  @since Added in version 1.0.
     *
     *  @ingroup init
     */
    public static void glfwTerminate()
    {
        try {MTD$glfwTerminate.invokeExact();}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the specified init hint to the desired value.
     *
     *  This function sets hints for the next initialization of GLFW.
     *
     *  The values you set hints to are never reset by GLFW, but they only take
     *  effect during initialization.  Once GLFW has been initialized, any values
     *  you set will be ignored until the library is terminated and initialized
     *  again.
     *
     *  Some hints are platform specific.  These may be set on any platform but they
     *  will only affect their specific platform.  Other platforms will ignore them.
     *  Setting these hints requires no platform specific headers or functions.
     *
     *  @param[in] hint The [init hint](@ref init_hints) to set.
     *  @param[in] value The new value of the init hint.
     *
     *  @errors Possible errors include @ref GLFW_INVALID_ENUM and @ref
     *  GLFW_INVALID_VALUE.
     *
     *  @remarks This function may be called before @ref glfwInit.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa init_hints
     *  @sa glfwInit
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup init
     */
    public static void glfwInitHint(int hint, int value)
    {
        try {MTD$glfwInitHint.invokeExact(hint, value);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Retrieves the version of the GLFW library.
     *
     *  This function retrieves the major, minor and revision numbers of the GLFW
     *  library.  It is intended for when you are using GLFW as a shared library and
     *  want to ensure that you are using the minimum required version.
     *
     *  Any or all of the version arguments may be `NULL`.
     *
     *  @param[out] major Where to store the major version number, or `NULL`.
     *  @param[out] minor Where to store the minor version number, or `NULL`.
     *  @param[out] rev Where to store the revision number, or `NULL`.
     *
     *  @errors None.
     *
     *  @remark This function may be called before @ref glfwInit.
     *
     *  @thread_safety This function may be called from any thread.
     *
     *  @sa @ref intro_version
     *  @sa @ref glfwGetVersionString
     *
     *  @since Added in version 1.0.
     *
     *  @ingroup init
     */
    public static void glfwGetVersion(java.lang.foreign.MemorySegment major, java.lang.foreign.MemorySegment minor, java.lang.foreign.MemorySegment rev)
    {
        try {MTD$glfwGetVersion.invokeExact(major, minor, rev);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns a string describing the compile-time configuration.
     *
     *  This function returns the compile-time generated
     *  [version string](@ref intro_version_string) of the GLFW library binary.  It
     *  describes the version, platform, compiler and any platform-specific
     *  compile-time options.  It should not be confused with the OpenGL or OpenGL
     *  ES version string, queried with `glGetString`.
     *
     *  __Do not use the version string__ to parse the GLFW library version.  The
     *  @ref glfwGetVersion function provides the version of the running library
     *  binary in numerical format.
     *
     *  @return The ASCII encoded GLFW version string.
     *
     *  @errors None.
     *
     *  @remark This function may be called before @ref glfwInit.
     *
     *  @pointer_lifetime The returned string is static and compile-time generated.
     *
     *  @thread_safety This function may be called from any thread.
     *
     *  @sa @ref intro_version
     *  @sa @ref glfwGetVersion
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup init
     */
    public static java.lang.foreign.MemorySegment glfwGetVersionString()
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetVersionString.invokeExact();}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns and clears the last error for the calling thread.
     *
     *  This function returns and clears the [error code](@ref errors) of the last
     *  error that occurred on the calling thread, and optionally a UTF-8 encoded
     *  human-readable description of it.  If no error has occurred since the last
     *  call, it returns @ref GLFW_NO_ERROR (zero) and the description pointer is
     *  set to `NULL`.
     *
     *  @param[in] description Where to store the error description pointer, or `NULL`.
     *  @return The last error code for the calling thread, or @ref GLFW_NO_ERROR
     *  (zero).
     *
     *  @errors None.
     *
     *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You
     *  should not free it yourself.  It is guaranteed to be valid only until the
     *  next error occurs or the library is terminated.
     *
     *  @remark This function may be called before @ref glfwInit.
     *
     *  @thread_safety This function may be called from any thread.
     *
     *  @sa @ref error_handling
     *  @sa @ref glfwSetErrorCallback
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup init
     */
    public static int glfwGetError(java.lang.foreign.MemorySegment description)
    {
        try {return (int)MTD$glfwGetError.invokeExact(description);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the error callback.
     *
     *  This function sets the error callback, which is called with an error code
     *  and a human-readable description each time a GLFW error occurs.
     *
     *  The error code is set before the callback is called.  Calling @ref
     *  glfwGetError from the error callback will return the same value as the error
     *  code argument.
     *
     *  The error callback is called on the thread where the error occurred.  If you
     *  are using GLFW from multiple threads, your error callback needs to be
     *  written accordingly.
     *
     *  Because the description string may have been generated specifically for that
     *  error, it is not guaranteed to be valid after the callback has returned.  If
     *  you wish to use it after the callback returns, you need to make a copy.
     *
     *  Once set, the error callback remains set even after the library has been
     *  terminated.
     *
     *  @param[in] callback The new callback, or `NULL` to remove the currently set
     *  callback.
     *  @return The previously set callback, or `NULL` if no callback was set.
     *
     *  @callback_signature
     *  @code
     *  void callback_name(int error_code, const char* description)
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [callback pointer type](@ref GLFWerrorfun).
     *
     *  @errors None.
     *
     *  @remark This function may be called before @ref glfwInit.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref error_handling
     *  @sa @ref glfwGetError
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup init
     */
    public static java.lang.foreign.MemorySegment glfwSetErrorCallback(java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetErrorCallback.invokeExact(callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the currently connected monitors.
     *
     *  This function returns an array of handles for all currently connected
     *  monitors.  The primary monitor is always first in the returned array.  If no
     *  monitors were found, this function returns `NULL`.
     *
     *  @param[out] count Where to store the number of monitors in the returned
     *  array.  This is set to zero if an error occurred.
     *  @return An array of monitor handles, or `NULL` if no monitors were found or
     *  if an [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @pointer_lifetime The returned array is allocated and freed by GLFW.  You
     *  should not free it yourself.  It is guaranteed to be valid only until the
     *  monitor configuration changes or the library is terminated.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref monitor_monitors
     *  @sa @ref monitor_event
     *  @sa @ref glfwGetPrimaryMonitor
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup monitor
     */
    public static java.lang.foreign.MemorySegment glfwGetMonitors(java.lang.foreign.MemorySegment count)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetMonitors.invokeExact(count);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the primary monitor.
     *
     *  This function returns the primary monitor.  This is usually the monitor
     *  where elements like the task bar or global menu bar are located.
     *
     *  @return The primary monitor, or `NULL` if no monitors were found or if an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @remark The primary monitor is always first in the array returned by @ref
     *  glfwGetMonitors.
     *
     *  @sa @ref monitor_monitors
     *  @sa @ref glfwGetMonitors
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup monitor
     */
    public static java.lang.foreign.MemorySegment glfwGetPrimaryMonitor()
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetPrimaryMonitor.invokeExact();}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the position of the monitor's viewport on the virtual screen.
     *
     *  This function returns the position, in screen coordinates, of the upper-left
     *  corner of the specified monitor.
     *
     *  Any or all of the position arguments may be `NULL`.  If an error occurs, all
     *  non-`NULL` position arguments will be set to zero.
     *
     *  @param[in] monitor The monitor to query.
     *  @param[out] xpos Where to store the monitor x-coordinate, or `NULL`.
     *  @param[out] ypos Where to store the monitor y-coordinate, or `NULL`.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref monitor_properties
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup monitor
     */
    public static void glfwGetMonitorPos(java.lang.foreign.MemorySegment monitor, java.lang.foreign.MemorySegment xpos, java.lang.foreign.MemorySegment ypos)
    {
        try {MTD$glfwGetMonitorPos.invokeExact(monitor, xpos, ypos);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Retrieves the work area of the monitor.
     *
     *  This function returns the position, in screen coordinates, of the upper-left
     *  corner of the work area of the specified monitor along with the work area
     *  size in screen coordinates. The work area is defined as the area of the
     *  monitor not occluded by the operating system task bar where present. If no
     *  task bar exists then the work area is the monitor resolution in screen
     *  coordinates.
     *
     *  Any or all of the position and size arguments may be `NULL`.  If an error
     *  occurs, all non-`NULL` position and size arguments will be set to zero.
     *
     *  @param[in] monitor The monitor to query.
     *  @param[out] xpos Where to store the monitor x-coordinate, or `NULL`.
     *  @param[out] ypos Where to store the monitor y-coordinate, or `NULL`.
     *  @param[out] width Where to store the monitor width, or `NULL`.
     *  @param[out] height Where to store the monitor height, or `NULL`.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref monitor_workarea
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup monitor
     */
    public static void glfwGetMonitorWorkarea(java.lang.foreign.MemorySegment monitor, java.lang.foreign.MemorySegment xpos, java.lang.foreign.MemorySegment ypos, java.lang.foreign.MemorySegment width, java.lang.foreign.MemorySegment height)
    {
        try {MTD$glfwGetMonitorWorkarea.invokeExact(monitor, xpos, ypos, width, height);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the physical size of the monitor.
     *
     *  This function returns the size, in millimetres, of the display area of the
     *  specified monitor.
     *
     *  Some systems do not provide accurate monitor size information, either
     *  because the monitor
     *  [EDID](https://en.wikipedia.org/wiki/Extended_display_identification_data)
     *  data is incorrect or because the driver does not report it accurately.
     *
     *  Any or all of the size arguments may be `NULL`.  If an error occurs, all
     *  non-`NULL` size arguments will be set to zero.
     *
     *  @param[in] monitor The monitor to query.
     *  @param[out] widthMM Where to store the width, in millimetres, of the
     *  monitor's display area, or `NULL`.
     *  @param[out] heightMM Where to store the height, in millimetres, of the
     *  monitor's display area, or `NULL`.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @remark @win32 On Windows 8 and earlier the physical size is calculated from
     *  the current resolution and system DPI instead of querying the monitor EDID data.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref monitor_properties
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup monitor
     */
    public static void glfwGetMonitorPhysicalSize(java.lang.foreign.MemorySegment monitor, java.lang.foreign.MemorySegment widthMM, java.lang.foreign.MemorySegment heightMM)
    {
        try {MTD$glfwGetMonitorPhysicalSize.invokeExact(monitor, widthMM, heightMM);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Retrieves the content scale for the specified monitor.
     *
     *  This function retrieves the content scale for the specified monitor.  The
     *  content scale is the ratio between the current DPI and the platform's
     *  default DPI.  This is especially important for text and any UI elements.  If
     *  the pixel dimensions of your UI scaled by this look appropriate on your
     *  machine then it should appear at a reasonable size on other machines
     *  regardless of their DPI and scaling settings.  This relies on the system DPI
     *  and scaling settings being somewhat correct.
     *
     *  The content scale may depend on both the monitor resolution and pixel
     *  density and on user settings.  It may be very different from the raw DPI
     *  calculated from the physical size and current resolution.
     *
     *  @param[in] monitor The monitor to query.
     *  @param[out] xscale Where to store the x-axis content scale, or `NULL`.
     *  @param[out] yscale Where to store the y-axis content scale, or `NULL`.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref monitor_scale
     *  @sa @ref glfwGetWindowContentScale
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup monitor
     */
    public static void glfwGetMonitorContentScale(java.lang.foreign.MemorySegment monitor, java.lang.foreign.MemorySegment xscale, java.lang.foreign.MemorySegment yscale)
    {
        try {MTD$glfwGetMonitorContentScale.invokeExact(monitor, xscale, yscale);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the name of the specified monitor.
     *
     *  This function returns a human-readable name, encoded as UTF-8, of the
     *  specified monitor.  The name typically reflects the make and model of the
     *  monitor and is not guaranteed to be unique among the connected monitors.
     *
     *  @param[in] monitor The monitor to query.
     *  @return The UTF-8 encoded name of the monitor, or `NULL` if an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You
     *  should not free it yourself.  It is valid until the specified monitor is
     *  disconnected or the library is terminated.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref monitor_properties
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup monitor
     */
    public static java.lang.foreign.MemorySegment glfwGetMonitorName(java.lang.foreign.MemorySegment monitor)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetMonitorName.invokeExact(monitor);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the user pointer of the specified monitor.
     *
     *  This function sets the user-defined pointer of the specified monitor.  The
     *  current value is retained until the monitor is disconnected.  The initial
     *  value is `NULL`.
     *
     *  This function may be called from the monitor callback, even for a monitor
     *  that is being disconnected.
     *
     *  @param[in] monitor The monitor whose pointer to set.
     *  @param[in] pointer The new value.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function may be called from any thread.  Access is not
     *  synchronized.
     *
     *  @sa @ref monitor_userptr
     *  @sa @ref glfwGetMonitorUserPointer
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup monitor
     */
    public static void glfwSetMonitorUserPointer(java.lang.foreign.MemorySegment monitor, java.lang.foreign.MemorySegment pointer)
    {
        try {MTD$glfwSetMonitorUserPointer.invokeExact(monitor, pointer);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the user pointer of the specified monitor.
     *
     *  This function returns the current value of the user-defined pointer of the
     *  specified monitor.  The initial value is `NULL`.
     *
     *  This function may be called from the monitor callback, even for a monitor
     *  that is being disconnected.
     *
     *  @param[in] monitor The monitor whose pointer to return.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function may be called from any thread.  Access is not
     *  synchronized.
     *
     *  @sa @ref monitor_userptr
     *  @sa @ref glfwSetMonitorUserPointer
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup monitor
     */
    public static java.lang.foreign.MemorySegment glfwGetMonitorUserPointer(java.lang.foreign.MemorySegment monitor)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetMonitorUserPointer.invokeExact(monitor);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the monitor configuration callback.
     *
     *  This function sets the monitor configuration callback, or removes the
     *  currently set callback.  This is called when a monitor is connected to or
     *  disconnected from the system.
     *
     *  @param[in] callback The new callback, or `NULL` to remove the currently set
     *  callback.
     *  @return The previously set callback, or `NULL` if no callback was set or the
     *  library had not been [initialized](@ref intro_init).
     *
     *  @callback_signature
     *  @code
     *  void function_name(GLFWmonitor* monitor, int event)
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [function pointer type](@ref GLFWmonitorfun).
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref monitor_event
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup monitor
     */
    public static java.lang.foreign.MemorySegment glfwSetMonitorCallback(java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetMonitorCallback.invokeExact(callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the available video modes for the specified monitor.
     *
     *  This function returns an array of all video modes supported by the specified
     *  monitor.  The returned array is sorted in ascending order, first by color
     *  bit depth (the sum of all channel depths), then by resolution area (the
     *  product of width and height), then resolution width and finally by refresh
     *  rate.
     *
     *  @param[in] monitor The monitor to query.
     *  @param[out] count Where to store the number of video modes in the returned
     *  array.  This is set to zero if an error occurred.
     *  @return An array of video modes, or `NULL` if an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @pointer_lifetime The returned array is allocated and freed by GLFW.  You
     *  should not free it yourself.  It is valid until the specified monitor is
     *  disconnected, this function is called again for that monitor or the library
     *  is terminated.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref monitor_modes
     *  @sa @ref glfwGetVideoMode
     *
     *  @since Added in version 1.0.
     *  @glfw3 Changed to return an array of modes for a specific monitor.
     *
     *  @ingroup monitor
     */
    public static java.lang.foreign.MemorySegment glfwGetVideoModes(java.lang.foreign.MemorySegment monitor, java.lang.foreign.MemorySegment count)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetVideoModes.invokeExact(monitor, count);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the current mode of the specified monitor.
     *
     *  This function returns the current video mode of the specified monitor.  If
     *  you have created a full screen window for that monitor, the return value
     *  will depend on whether that window is iconified.
     *
     *  @param[in] monitor The monitor to query.
     *  @return The current mode of the monitor, or `NULL` if an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @pointer_lifetime The returned array is allocated and freed by GLFW.  You
     *  should not free it yourself.  It is valid until the specified monitor is
     *  disconnected or the library is terminated.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref monitor_modes
     *  @sa @ref glfwGetVideoModes
     *
     *  @since Added in version 3.0.  Replaces `glfwGetDesktopMode`.
     *
     *  @ingroup monitor
     */
    public static java.lang.foreign.MemorySegment glfwGetVideoMode(java.lang.foreign.MemorySegment monitor)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetVideoMode.invokeExact(monitor);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Generates a gamma ramp and sets it for the specified monitor.
     *
     *  This function generates an appropriately sized gamma ramp from the specified
     *  exponent and then calls @ref glfwSetGammaRamp with it.  The value must be
     *  a finite number greater than zero.
     *
     *  The software controlled gamma ramp is applied _in addition_ to the hardware
     *  gamma correction, which today is usually an approximation of sRGB gamma.
     *  This means that setting a perfectly linear ramp, or gamma 1.0, will produce
     *  the default (usually sRGB-like) behavior.
     *
     *  For gamma correct rendering with OpenGL or OpenGL ES, see the @ref
     *  GLFW_SRGB_CAPABLE hint.
     *
     *  @param[in] monitor The monitor whose gamma ramp to set.
     *  @param[in] gamma The desired exponent.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.
     *
     *  @remark @wayland Gamma handling is a privileged protocol, this function
     *  will thus never be implemented and emits @ref GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref monitor_gamma
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup monitor
     */
    public static void glfwSetGamma(java.lang.foreign.MemorySegment monitor, float gamma)
    {
        try {MTD$glfwSetGamma.invokeExact(monitor, gamma);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the current gamma ramp for the specified monitor.
     *
     *  This function returns the current gamma ramp of the specified monitor.
     *
     *  @param[in] monitor The monitor to query.
     *  @return The current gamma ramp, or `NULL` if an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @remark @wayland Gamma handling is a privileged protocol, this function
     *  will thus never be implemented and emits @ref GLFW_PLATFORM_ERROR while
     *  returning `NULL`.
     *
     *  @pointer_lifetime The returned structure and its arrays are allocated and
     *  freed by GLFW.  You should not free them yourself.  They are valid until the
     *  specified monitor is disconnected, this function is called again for that
     *  monitor or the library is terminated.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref monitor_gamma
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup monitor
     */
    public static java.lang.foreign.MemorySegment glfwGetGammaRamp(java.lang.foreign.MemorySegment monitor)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetGammaRamp.invokeExact(monitor);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the current gamma ramp for the specified monitor.
     *
     *  This function sets the current gamma ramp for the specified monitor.  The
     *  original gamma ramp for that monitor is saved by GLFW the first time this
     *  function is called and is restored by @ref glfwTerminate.
     *
     *  The software controlled gamma ramp is applied _in addition_ to the hardware
     *  gamma correction, which today is usually an approximation of sRGB gamma.
     *  This means that setting a perfectly linear ramp, or gamma 1.0, will produce
     *  the default (usually sRGB-like) behavior.
     *
     *  For gamma correct rendering with OpenGL or OpenGL ES, see the @ref
     *  GLFW_SRGB_CAPABLE hint.
     *
     *  @param[in] monitor The monitor whose gamma ramp to set.
     *  @param[in] ramp The gamma ramp to use.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @remark The size of the specified gamma ramp should match the size of the
     *  current ramp for that monitor.
     *
     *  @remark @win32 The gamma ramp size must be 256.
     *
     *  @remark @wayland Gamma handling is a privileged protocol, this function
     *  will thus never be implemented and emits @ref GLFW_PLATFORM_ERROR.
     *
     *  @pointer_lifetime The specified gamma ramp is copied before this function
     *  returns.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref monitor_gamma
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup monitor
     */
    public static void glfwSetGammaRamp(java.lang.foreign.MemorySegment monitor, java.lang.foreign.MemorySegment ramp)
    {
        try {MTD$glfwSetGammaRamp.invokeExact(monitor, ramp);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Resets all window hints to their default values.
     *
     *  This function resets all window hints to their
     *  [default values](@ref window_hints_values).
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_hints
     *  @sa @ref glfwWindowHint
     *  @sa @ref glfwWindowHintString
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup window
     */
    public static void glfwDefaultWindowHints()
    {
        try {MTD$glfwDefaultWindowHints.invokeExact();}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the specified window hint to the desired value.
     *
     *  This function sets hints for the next call to @ref glfwCreateWindow.  The
     *  hints, once set, retain their values until changed by a call to this
     *  function or @ref glfwDefaultWindowHints, or until the library is terminated.
     *
     *  Only integer value hints can be set with this function.  String value hints
     *  are set with @ref glfwWindowHintString.
     *
     *  This function does not check whether the specified hint values are valid.
     *  If you set hints to invalid values this will instead be reported by the next
     *  call to @ref glfwCreateWindow.
     *
     *  Some hints are platform specific.  These may be set on any platform but they
     *  will only affect their specific platform.  Other platforms will ignore them.
     *  Setting these hints requires no platform specific headers or functions.
     *
     *  @param[in] hint The [window hint](@ref window_hints) to set.
     *  @param[in] value The new value of the window hint.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_INVALID_ENUM.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_hints
     *  @sa @ref glfwWindowHintString
     *  @sa @ref glfwDefaultWindowHints
     *
     *  @since Added in version 3.0.  Replaces `glfwOpenWindowHint`.
     *
     *  @ingroup window
     */
    public static void glfwWindowHint(int hint, int value)
    {
        try {MTD$glfwWindowHint.invokeExact(hint, value);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the specified window hint to the desired value.
     *
     *  This function sets hints for the next call to @ref glfwCreateWindow.  The
     *  hints, once set, retain their values until changed by a call to this
     *  function or @ref glfwDefaultWindowHints, or until the library is terminated.
     *
     *  Only string type hints can be set with this function.  Integer value hints
     *  are set with @ref glfwWindowHint.
     *
     *  This function does not check whether the specified hint values are valid.
     *  If you set hints to invalid values this will instead be reported by the next
     *  call to @ref glfwCreateWindow.
     *
     *  Some hints are platform specific.  These may be set on any platform but they
     *  will only affect their specific platform.  Other platforms will ignore them.
     *  Setting these hints requires no platform specific headers or functions.
     *
     *  @param[in] hint The [window hint](@ref window_hints) to set.
     *  @param[in] value The new value of the window hint.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_INVALID_ENUM.
     *
     *  @pointer_lifetime The specified string is copied before this function
     *  returns.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_hints
     *  @sa @ref glfwWindowHint
     *  @sa @ref glfwDefaultWindowHints
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup window
     */
    public static void glfwWindowHintString(int hint, java.lang.foreign.MemorySegment value)
    {
        try {MTD$glfwWindowHintString.invokeExact(hint, value);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Creates a window and its associated context.
     *
     *  This function creates a window and its associated OpenGL or OpenGL ES
     *  context.  Most of the options controlling how the window and its context
     *  should be created are specified with [window hints](@ref window_hints).
     *
     *  Successful creation does not change which context is current.  Before you
     *  can use the newly created context, you need to
     *  [make it current](@ref context_current).  For information about the `share`
     *  parameter, see @ref context_sharing.
     *
     *  The created window, framebuffer and context may differ from what you
     *  requested, as not all parameters and hints are
     *  [hard constraints](@ref window_hints_hard).  This includes the size of the
     *  window, especially for full screen windows.  To query the actual attributes
     *  of the created window, framebuffer and context, see @ref
     *  glfwGetWindowAttrib, @ref glfwGetWindowSize and @ref glfwGetFramebufferSize.
     *
     *  To create a full screen window, you need to specify the monitor the window
     *  will cover.  If no monitor is specified, the window will be windowed mode.
     *  Unless you have a way for the user to choose a specific monitor, it is
     *  recommended that you pick the primary monitor.  For more information on how
     *  to query connected monitors, see @ref monitor_monitors.
     *
     *  For full screen windows, the specified size becomes the resolution of the
     *  window's _desired video mode_.  As long as a full screen window is not
     *  iconified, the supported video mode most closely matching the desired video
     *  mode is set for the specified monitor.  For more information about full
     *  screen windows, including the creation of so called _windowed full screen_
     *  or _borderless full screen_ windows, see @ref window_windowed_full_screen.
     *
     *  Once you have created the window, you can switch it between windowed and
     *  full screen mode with @ref glfwSetWindowMonitor.  This will not affect its
     *  OpenGL or OpenGL ES context.
     *
     *  By default, newly created windows use the placement recommended by the
     *  window system.  To create the window at a specific position, make it
     *  initially invisible using the [GLFW_VISIBLE](@ref GLFW_VISIBLE_hint) window
     *  hint, set its [position](@ref window_pos) and then [show](@ref window_hide)
     *  it.
     *
     *  As long as at least one full screen window is not iconified, the screensaver
     *  is prohibited from starting.
     *
     *  Window systems put limits on window sizes.  Very large or very small window
     *  dimensions may be overridden by the window system on creation.  Check the
     *  actual [size](@ref window_size) after creation.
     *
     *  The [swap interval](@ref buffer_swap) is not set during window creation and
     *  the initial value may vary depending on driver settings and defaults.
     *
     *  @param[in] width The desired width, in screen coordinates, of the window.
     *  This must be greater than zero.
     *  @param[in] height The desired height, in screen coordinates, of the window.
     *  This must be greater than zero.
     *  @param[in] title The initial, UTF-8 encoded window title.
     *  @param[in] monitor The monitor to use for full screen mode, or `NULL` for
     *  windowed mode.
     *  @param[in] share The window whose context to share resources with, or `NULL`
     *  to not share resources.
     *  @return The handle of the created window, or `NULL` if an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_INVALID_ENUM, @ref GLFW_INVALID_VALUE, @ref GLFW_API_UNAVAILABLE, @ref
     *  GLFW_VERSION_UNAVAILABLE, @ref GLFW_FORMAT_UNAVAILABLE and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @remark @win32 Window creation will fail if the Microsoft GDI software
     *  OpenGL implementation is the only one available.
     *
     *  @remark @win32 If the executable has an icon resource named `GLFW_ICON,` it
     *  will be set as the initial icon for the window.  If no such icon is present,
     *  the `IDI_APPLICATION` icon will be used instead.  To set a different icon,
     *  see @ref glfwSetWindowIcon.
     *
     *  @remark @win32 The context to share resources with must not be current on
     *  any other thread.
     *
     *  @remark @macos The OS only supports forward-compatible core profile contexts
     *  for OpenGL versions 3.2 and later.  Before creating an OpenGL context of
     *  version 3.2 or later you must set the
     *  [GLFW_OPENGL_FORWARD_COMPAT](@ref GLFW_OPENGL_FORWARD_COMPAT_hint) and
     *  [GLFW_OPENGL_PROFILE](@ref GLFW_OPENGL_PROFILE_hint) hints accordingly.
     *  OpenGL 3.0 and 3.1 contexts are not supported at all on macOS.
     *
     *  @remark @macos The GLFW window has no icon, as it is not a document
     *  window, but the dock icon will be the same as the application bundle's icon.
     *  For more information on bundles, see the
     *  [Bundle Programming Guide](https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/)
     *  in the Mac Developer Library.
     *
     *  @remark @macos The first time a window is created the menu bar is created.
     *  If GLFW finds a `MainMenu.nib` it is loaded and assumed to contain a menu
     *  bar.  Otherwise a minimal menu bar is created manually with common commands
     *  like Hide, Quit and About.  The About entry opens a minimal about dialog
     *  with information from the application's bundle.  Menu bar creation can be
     *  disabled entirely with the @ref GLFW_COCOA_MENUBAR init hint.
     *
     *  @remark @macos On OS X 10.10 and later the window frame will not be rendered
     *  at full resolution on Retina displays unless the
     *  [GLFW_COCOA_RETINA_FRAMEBUFFER](@ref GLFW_COCOA_RETINA_FRAMEBUFFER_hint)
     *  hint is `GLFW_TRUE` and the `NSHighResolutionCapable` key is enabled in the
     *  application bundle's `Info.plist`.  For more information, see
     *  [High Resolution Guidelines for OS X](https://developer.apple.com/library/mac/documentation/GraphicsAnimation/Conceptual/HighResolutionOSX/Explained/Explained.html)
     *  in the Mac Developer Library.  The GLFW test and example programs use
     *  a custom `Info.plist` template for this, which can be found as
     *  `CMake/MacOSXBundleInfo.plist.in` in the source tree.
     *
     *  @remark @macos When activating frame autosaving with
     *  [GLFW_COCOA_FRAME_NAME](@ref GLFW_COCOA_FRAME_NAME_hint), the specified
     *  window size and position may be overridden by previously saved values.
     *
     *  @remark @x11 Some window managers will not respect the placement of
     *  initially hidden windows.
     *
     *  @remark @x11 Due to the asynchronous nature of X11, it may take a moment for
     *  a window to reach its requested state.  This means you may not be able to
     *  query the final size, position or other attributes directly after window
     *  creation.
     *
     *  @remark @x11 The class part of the `WM_CLASS` window property will by
     *  default be set to the window title passed to this function.  The instance
     *  part will use the contents of the `RESOURCE_NAME` environment variable, if
     *  present and not empty, or fall back to the window title.  Set the
     *  [GLFW_X11_CLASS_NAME](@ref GLFW_X11_CLASS_NAME_hint) and
     *  [GLFW_X11_INSTANCE_NAME](@ref GLFW_X11_INSTANCE_NAME_hint) window hints to
     *  override this.
     *
     *  @remark @wayland Compositors should implement the xdg-decoration protocol
     *  for GLFW to decorate the window properly.  If this protocol isn't
     *  supported, or if the compositor prefers client-side decorations, a very
     *  simple fallback frame will be drawn using the wp_viewporter protocol.  A
     *  compositor can still emit close, maximize or fullscreen events, using for
     *  instance a keybind mechanism.  If neither of these protocols is supported,
     *  the window won't be decorated.
     *
     *  @remark @wayland A full screen window will not attempt to change the mode,
     *  no matter what the requested size or refresh rate.
     *
     *  @remark @wayland Screensaver inhibition requires the idle-inhibit protocol
     *  to be implemented in the user's compositor.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_creation
     *  @sa @ref glfwDestroyWindow
     *
     *  @since Added in version 3.0.  Replaces `glfwOpenWindow`.
     *
     *  @ingroup window
     */
    public static java.lang.foreign.MemorySegment glfwCreateWindow(int width, int height, java.lang.foreign.MemorySegment title, java.lang.foreign.MemorySegment monitor, java.lang.foreign.MemorySegment share)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwCreateWindow.invokeExact(width, height, title, monitor, share);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Destroys the specified window and its context.
     *
     *  This function destroys the specified window and its context.  On calling
     *  this function, no further callbacks will be called for that window.
     *
     *  If the context of the specified window is current on the main thread, it is
     *  detached before being destroyed.
     *
     *  @param[in] window The window to destroy.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @note The context of the specified window must not be current on any other
     *  thread when this function is called.
     *
     *  @reentrancy This function must not be called from a callback.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_creation
     *  @sa @ref glfwCreateWindow
     *
     *  @since Added in version 3.0.  Replaces `glfwCloseWindow`.
     *
     *  @ingroup window
     */
    public static void glfwDestroyWindow(java.lang.foreign.MemorySegment window)
    {
        try {MTD$glfwDestroyWindow.invokeExact(window);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Checks the close flag of the specified window.
     *
     *  This function returns the value of the close flag of the specified window.
     *
     *  @param[in] window The window to query.
     *  @return The value of the close flag.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function may be called from any thread.  Access is not
     *  synchronized.
     *
     *  @sa @ref window_close
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup window
     */
    public static int glfwWindowShouldClose(java.lang.foreign.MemorySegment window)
    {
        try {return (int)MTD$glfwWindowShouldClose.invokeExact(window);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the close flag of the specified window.
     *
     *  This function sets the value of the close flag of the specified window.
     *  This can be used to override the user's attempt to close the window, or
     *  to signal that it should be closed.
     *
     *  @param[in] window The window whose flag to change.
     *  @param[in] value The new value.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function may be called from any thread.  Access is not
     *  synchronized.
     *
     *  @sa @ref window_close
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup window
     */
    public static void glfwSetWindowShouldClose(java.lang.foreign.MemorySegment window, int value)
    {
        try {MTD$glfwSetWindowShouldClose.invokeExact(window, value);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the title of the specified window.
     *
     *  This function sets the window title, encoded as UTF-8, of the specified
     *  window.
     *
     *  @param[in] window The window whose title to change.
     *  @param[in] title The UTF-8 encoded window title.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @remark @macos The window title will not be updated until the next time you
     *  process events.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_title
     *
     *  @since Added in version 1.0.
     *  @glfw3 Added window handle parameter.
     *
     *  @ingroup window
     */
    public static void glfwSetWindowTitle(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment title)
    {
        try {MTD$glfwSetWindowTitle.invokeExact(window, title);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the icon for the specified window.
     *
     *  This function sets the icon of the specified window.  If passed an array of
     *  candidate images, those of or closest to the sizes desired by the system are
     *  selected.  If no images are specified, the window reverts to its default
     *  icon.
     *
     *  The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight
     *  bits per channel with the red channel first.  They are arranged canonically
     *  as packed sequential rows, starting from the top-left corner.
     *
     *  The desired image sizes varies depending on platform and system settings.
     *  The selected images will be rescaled as needed.  Good sizes include 16x16,
     *  32x32 and 48x48.
     *
     *  @param[in] window The window whose icon to set.
     *  @param[in] count The number of images in the specified array, or zero to
     *  revert to the default window icon.
     *  @param[in] images The images to create the icon from.  This is ignored if
     *  count is zero.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.
     *
     *  @pointer_lifetime The specified image data is copied before this function
     *  returns.
     *
     *  @remark @macos The GLFW window has no icon, as it is not a document
     *  window, so this function does nothing.  The dock icon will be the same as
     *  the application bundle's icon.  For more information on bundles, see the
     *  [Bundle Programming Guide](https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/)
     *  in the Mac Developer Library.
     *
     *  @remark @wayland There is no existing protocol to change an icon, the
     *  window will thus inherit the one defined in the application's desktop file.
     *  This function always emits @ref GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_icon
     *
     *  @since Added in version 3.2.
     *
     *  @ingroup window
     */
    public static void glfwSetWindowIcon(java.lang.foreign.MemorySegment window, int count, java.lang.foreign.MemorySegment images)
    {
        try {MTD$glfwSetWindowIcon.invokeExact(window, count, images);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Retrieves the position of the content area of the specified window.
     *
     *  This function retrieves the position, in screen coordinates, of the
     *  upper-left corner of the content area of the specified window.
     *
     *  Any or all of the position arguments may be `NULL`.  If an error occurs, all
     *  non-`NULL` position arguments will be set to zero.
     *
     *  @param[in] window The window to query.
     *  @param[out] xpos Where to store the x-coordinate of the upper-left corner of
     *  the content area, or `NULL`.
     *  @param[out] ypos Where to store the y-coordinate of the upper-left corner of
     *  the content area, or `NULL`.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @remark @wayland There is no way for an application to retrieve the global
     *  position of its windows, this function will always emit @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_pos
     *  @sa @ref glfwSetWindowPos
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup window
     */
    public static void glfwGetWindowPos(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment xpos, java.lang.foreign.MemorySegment ypos)
    {
        try {MTD$glfwGetWindowPos.invokeExact(window, xpos, ypos);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the position of the content area of the specified window.
     *
     *  This function sets the position, in screen coordinates, of the upper-left
     *  corner of the content area of the specified windowed mode window.  If the
     *  window is a full screen window, this function does nothing.
     *
     *  __Do not use this function__ to move an already visible window unless you
     *  have very good reasons for doing so, as it will confuse and annoy the user.
     *
     *  The window manager may put limits on what positions are allowed.  GLFW
     *  cannot and should not override these limits.
     *
     *  @param[in] window The window to query.
     *  @param[in] xpos The x-coordinate of the upper-left corner of the content area.
     *  @param[in] ypos The y-coordinate of the upper-left corner of the content area.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @remark @wayland There is no way for an application to set the global
     *  position of its windows, this function will always emit @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_pos
     *  @sa @ref glfwGetWindowPos
     *
     *  @since Added in version 1.0.
     *  @glfw3 Added window handle parameter.
     *
     *  @ingroup window
     */
    public static void glfwSetWindowPos(java.lang.foreign.MemorySegment window, int xpos, int ypos)
    {
        try {MTD$glfwSetWindowPos.invokeExact(window, xpos, ypos);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Retrieves the size of the content area of the specified window.
     *
     *  This function retrieves the size, in screen coordinates, of the content area
     *  of the specified window.  If you wish to retrieve the size of the
     *  framebuffer of the window in pixels, see @ref glfwGetFramebufferSize.
     *
     *  Any or all of the size arguments may be `NULL`.  If an error occurs, all
     *  non-`NULL` size arguments will be set to zero.
     *
     *  @param[in] window The window whose size to retrieve.
     *  @param[out] width Where to store the width, in screen coordinates, of the
     *  content area, or `NULL`.
     *  @param[out] height Where to store the height, in screen coordinates, of the
     *  content area, or `NULL`.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_size
     *  @sa @ref glfwSetWindowSize
     *
     *  @since Added in version 1.0.
     *  @glfw3 Added window handle parameter.
     *
     *  @ingroup window
     */
    public static void glfwGetWindowSize(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment width, java.lang.foreign.MemorySegment height)
    {
        try {MTD$glfwGetWindowSize.invokeExact(window, width, height);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the size limits of the specified window.
     *
     *  This function sets the size limits of the content area of the specified
     *  window.  If the window is full screen, the size limits only take effect
     *  once it is made windowed.  If the window is not resizable, this function
     *  does nothing.
     *
     *  The size limits are applied immediately to a windowed mode window and may
     *  cause it to be resized.
     *
     *  The maximum dimensions must be greater than or equal to the minimum
     *  dimensions and all must be greater than or equal to zero.
     *
     *  @param[in] window The window to set limits for.
     *  @param[in] minwidth The minimum width, in screen coordinates, of the content
     *  area, or `GLFW_DONT_CARE`.
     *  @param[in] minheight The minimum height, in screen coordinates, of the
     *  content area, or `GLFW_DONT_CARE`.
     *  @param[in] maxwidth The maximum width, in screen coordinates, of the content
     *  area, or `GLFW_DONT_CARE`.
     *  @param[in] maxheight The maximum height, in screen coordinates, of the
     *  content area, or `GLFW_DONT_CARE`.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.
     *
     *  @remark If you set size limits and an aspect ratio that conflict, the
     *  results are undefined.
     *
     *  @remark @wayland The size limits will not be applied until the window is
     *  actually resized, either by the user or by the compositor.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_sizelimits
     *  @sa @ref glfwSetWindowAspectRatio
     *
     *  @since Added in version 3.2.
     *
     *  @ingroup window
     */
    public static void glfwSetWindowSizeLimits(java.lang.foreign.MemorySegment window, int minwidth, int minheight, int maxwidth, int maxheight)
    {
        try {MTD$glfwSetWindowSizeLimits.invokeExact(window, minwidth, minheight, maxwidth, maxheight);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the aspect ratio of the specified window.
     *
     *  This function sets the required aspect ratio of the content area of the
     *  specified window.  If the window is full screen, the aspect ratio only takes
     *  effect once it is made windowed.  If the window is not resizable, this
     *  function does nothing.
     *
     *  The aspect ratio is specified as a numerator and a denominator and both
     *  values must be greater than zero.  For example, the common 16:9 aspect ratio
     *  is specified as 16 and 9, respectively.
     *
     *  If the numerator and denominator is set to `GLFW_DONT_CARE` then the aspect
     *  ratio limit is disabled.
     *
     *  The aspect ratio is applied immediately to a windowed mode window and may
     *  cause it to be resized.
     *
     *  @param[in] window The window to set limits for.
     *  @param[in] numer The numerator of the desired aspect ratio, or
     *  `GLFW_DONT_CARE`.
     *  @param[in] denom The denominator of the desired aspect ratio, or
     *  `GLFW_DONT_CARE`.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.
     *
     *  @remark If you set size limits and an aspect ratio that conflict, the
     *  results are undefined.
     *
     *  @remark @wayland The aspect ratio will not be applied until the window is
     *  actually resized, either by the user or by the compositor.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_sizelimits
     *  @sa @ref glfwSetWindowSizeLimits
     *
     *  @since Added in version 3.2.
     *
     *  @ingroup window
     */
    public static void glfwSetWindowAspectRatio(java.lang.foreign.MemorySegment window, int numer, int denom)
    {
        try {MTD$glfwSetWindowAspectRatio.invokeExact(window, numer, denom);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the size of the content area of the specified window.
     *
     *  This function sets the size, in screen coordinates, of the content area of
     *  the specified window.
     *
     *  For full screen windows, this function updates the resolution of its desired
     *  video mode and switches to the video mode closest to it, without affecting
     *  the window's context.  As the context is unaffected, the bit depths of the
     *  framebuffer remain unchanged.
     *
     *  If you wish to update the refresh rate of the desired video mode in addition
     *  to its resolution, see @ref glfwSetWindowMonitor.
     *
     *  The window manager may put limits on what sizes are allowed.  GLFW cannot
     *  and should not override these limits.
     *
     *  @param[in] window The window to resize.
     *  @param[in] width The desired width, in screen coordinates, of the window
     *  content area.
     *  @param[in] height The desired height, in screen coordinates, of the window
     *  content area.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @remark @wayland A full screen window will not attempt to change the mode,
     *  no matter what the requested size.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_size
     *  @sa @ref glfwGetWindowSize
     *  @sa @ref glfwSetWindowMonitor
     *
     *  @since Added in version 1.0.
     *  @glfw3 Added window handle parameter.
     *
     *  @ingroup window
     */
    public static void glfwSetWindowSize(java.lang.foreign.MemorySegment window, int width, int height)
    {
        try {MTD$glfwSetWindowSize.invokeExact(window, width, height);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Retrieves the size of the framebuffer of the specified window.
     *
     *  This function retrieves the size, in pixels, of the framebuffer of the
     *  specified window.  If you wish to retrieve the size of the window in screen
     *  coordinates, see @ref glfwGetWindowSize.
     *
     *  Any or all of the size arguments may be `NULL`.  If an error occurs, all
     *  non-`NULL` size arguments will be set to zero.
     *
     *  @param[in] window The window whose framebuffer to query.
     *  @param[out] width Where to store the width, in pixels, of the framebuffer,
     *  or `NULL`.
     *  @param[out] height Where to store the height, in pixels, of the framebuffer,
     *  or `NULL`.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_fbsize
     *  @sa @ref glfwSetFramebufferSizeCallback
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup window
     */
    public static void glfwGetFramebufferSize(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment width, java.lang.foreign.MemorySegment height)
    {
        try {MTD$glfwGetFramebufferSize.invokeExact(window, width, height);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Retrieves the size of the frame of the window.
     *
     *  This function retrieves the size, in screen coordinates, of each edge of the
     *  frame of the specified window.  This size includes the title bar, if the
     *  window has one.  The size of the frame may vary depending on the
     *  [window-related hints](@ref window_hints_wnd) used to create it.
     *
     *  Because this function retrieves the size of each window frame edge and not
     *  the offset along a particular coordinate axis, the retrieved values will
     *  always be zero or positive.
     *
     *  Any or all of the size arguments may be `NULL`.  If an error occurs, all
     *  non-`NULL` size arguments will be set to zero.
     *
     *  @param[in] window The window whose frame size to query.
     *  @param[out] left Where to store the size, in screen coordinates, of the left
     *  edge of the window frame, or `NULL`.
     *  @param[out] top Where to store the size, in screen coordinates, of the top
     *  edge of the window frame, or `NULL`.
     *  @param[out] right Where to store the size, in screen coordinates, of the
     *  right edge of the window frame, or `NULL`.
     *  @param[out] bottom Where to store the size, in screen coordinates, of the
     *  bottom edge of the window frame, or `NULL`.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_size
     *
     *  @since Added in version 3.1.
     *
     *  @ingroup window
     */
    public static void glfwGetWindowFrameSize(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment left, java.lang.foreign.MemorySegment top, java.lang.foreign.MemorySegment right, java.lang.foreign.MemorySegment bottom)
    {
        try {MTD$glfwGetWindowFrameSize.invokeExact(window, left, top, right, bottom);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Retrieves the content scale for the specified window.
     *
     *  This function retrieves the content scale for the specified window.  The
     *  content scale is the ratio between the current DPI and the platform's
     *  default DPI.  This is especially important for text and any UI elements.  If
     *  the pixel dimensions of your UI scaled by this look appropriate on your
     *  machine then it should appear at a reasonable size on other machines
     *  regardless of their DPI and scaling settings.  This relies on the system DPI
     *  and scaling settings being somewhat correct.
     *
     *  On systems where each monitors can have its own content scale, the window
     *  content scale will depend on which monitor the system considers the window
     *  to be on.
     *
     *  @param[in] window The window to query.
     *  @param[out] xscale Where to store the x-axis content scale, or `NULL`.
     *  @param[out] yscale Where to store the y-axis content scale, or `NULL`.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_scale
     *  @sa @ref glfwSetWindowContentScaleCallback
     *  @sa @ref glfwGetMonitorContentScale
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup window
     */
    public static void glfwGetWindowContentScale(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment xscale, java.lang.foreign.MemorySegment yscale)
    {
        try {MTD$glfwGetWindowContentScale.invokeExact(window, xscale, yscale);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the opacity of the whole window.
     *
     *  This function returns the opacity of the window, including any decorations.
     *
     *  The opacity (or alpha) value is a positive finite number between zero and
     *  one, where zero is fully transparent and one is fully opaque.  If the system
     *  does not support whole window transparency, this function always returns one.
     *
     *  The initial opacity value for newly created windows is one.
     *
     *  @param[in] window The window to query.
     *  @return The opacity value of the specified window.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_transparency
     *  @sa @ref glfwSetWindowOpacity
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup window
     */
    public static float glfwGetWindowOpacity(java.lang.foreign.MemorySegment window)
    {
        try {return (float)MTD$glfwGetWindowOpacity.invokeExact(window);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the opacity of the whole window.
     *
     *  This function sets the opacity of the window, including any decorations.
     *
     *  The opacity (or alpha) value is a positive finite number between zero and
     *  one, where zero is fully transparent and one is fully opaque.
     *
     *  The initial opacity value for newly created windows is one.
     *
     *  A window created with framebuffer transparency may not use whole window
     *  transparency.  The results of doing this are undefined.
     *
     *  @param[in] window The window to set the opacity for.
     *  @param[in] opacity The desired opacity of the specified window.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_transparency
     *  @sa @ref glfwGetWindowOpacity
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup window
     */
    public static void glfwSetWindowOpacity(java.lang.foreign.MemorySegment window, float opacity)
    {
        try {MTD$glfwSetWindowOpacity.invokeExact(window, opacity);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Iconifies the specified window.
     *
     *  This function iconifies (minimizes) the specified window if it was
     *  previously restored.  If the window is already iconified, this function does
     *  nothing.
     *
     *  If the specified window is a full screen window, GLFW restores the original
     *  video mode of the monitor.  The window's desired video mode is set again
     *  when the window is restored.
     *
     *  @param[in] window The window to iconify.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_iconify
     *  @sa @ref glfwRestoreWindow
     *  @sa @ref glfwMaximizeWindow
     *
     *  @since Added in version 2.1.
     *  @glfw3 Added window handle parameter.
     *
     *  @ingroup window
     */
    public static void glfwIconifyWindow(java.lang.foreign.MemorySegment window)
    {
        try {MTD$glfwIconifyWindow.invokeExact(window);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Restores the specified window.
     *
     *  This function restores the specified window if it was previously iconified
     *  (minimized) or maximized.  If the window is already restored, this function
     *  does nothing.
     *
     *  If the specified window is an iconified full screen window, its desired
     *  video mode is set again for its monitor when the window is restored.
     *
     *  @param[in] window The window to restore.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_iconify
     *  @sa @ref glfwIconifyWindow
     *  @sa @ref glfwMaximizeWindow
     *
     *  @since Added in version 2.1.
     *  @glfw3 Added window handle parameter.
     *
     *  @ingroup window
     */
    public static void glfwRestoreWindow(java.lang.foreign.MemorySegment window)
    {
        try {MTD$glfwRestoreWindow.invokeExact(window);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Maximizes the specified window.
     *
     *  This function maximizes the specified window if it was previously not
     *  maximized.  If the window is already maximized, this function does nothing.
     *
     *  If the specified window is a full screen window, this function does nothing.
     *
     *  @param[in] window The window to maximize.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @par Thread Safety
     *  This function may only be called from the main thread.
     *
     *  @sa @ref window_iconify
     *  @sa @ref glfwIconifyWindow
     *  @sa @ref glfwRestoreWindow
     *
     *  @since Added in GLFW 3.2.
     *
     *  @ingroup window
     */
    public static void glfwMaximizeWindow(java.lang.foreign.MemorySegment window)
    {
        try {MTD$glfwMaximizeWindow.invokeExact(window);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Makes the specified window visible.
     *
     *  This function makes the specified window visible if it was previously
     *  hidden.  If the window is already visible or is in full screen mode, this
     *  function does nothing.
     *
     *  By default, windowed mode windows are focused when shown
     *  Set the [GLFW_FOCUS_ON_SHOW](@ref GLFW_FOCUS_ON_SHOW_hint) window hint
     *  to change this behavior for all newly created windows, or change the
     *  behavior for an existing window with @ref glfwSetWindowAttrib.
     *
     *  @param[in] window The window to make visible.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @remark @wayland Because Wayland wants every frame of the desktop to be
     *  complete, this function does not immediately make the window visible.
     *  Instead it will become visible the next time the window framebuffer is
     *  updated after this call.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_hide
     *  @sa @ref glfwHideWindow
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup window
     */
    public static void glfwShowWindow(java.lang.foreign.MemorySegment window)
    {
        try {MTD$glfwShowWindow.invokeExact(window);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Hides the specified window.
     *
     *  This function hides the specified window if it was previously visible.  If
     *  the window is already hidden or is in full screen mode, this function does
     *  nothing.
     *
     *  @param[in] window The window to hide.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_hide
     *  @sa @ref glfwShowWindow
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup window
     */
    public static void glfwHideWindow(java.lang.foreign.MemorySegment window)
    {
        try {MTD$glfwHideWindow.invokeExact(window);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Brings the specified window to front and sets input focus.
     *
     *  This function brings the specified window to front and sets input focus.
     *  The window should already be visible and not iconified.
     *
     *  By default, both windowed and full screen mode windows are focused when
     *  initially created.  Set the [GLFW_FOCUSED](@ref GLFW_FOCUSED_hint) to
     *  disable this behavior.
     *
     *  Also by default, windowed mode windows are focused when shown
     *  with @ref glfwShowWindow. Set the
     *  [GLFW_FOCUS_ON_SHOW](@ref GLFW_FOCUS_ON_SHOW_hint) to disable this behavior.
     *
     *  __Do not use this function__ to steal focus from other applications unless
     *  you are certain that is what the user wants.  Focus stealing can be
     *  extremely disruptive.
     *
     *  For a less disruptive way of getting the user's attention, see
     *  [attention requests](@ref window_attention).
     *
     *  @param[in] window The window to give input focus.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @remark @wayland It is not possible for an application to bring its windows
     *  to front, this function will always emit @ref GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_focus
     *  @sa @ref window_attention
     *
     *  @since Added in version 3.2.
     *
     *  @ingroup window
     */
    public static void glfwFocusWindow(java.lang.foreign.MemorySegment window)
    {
        try {MTD$glfwFocusWindow.invokeExact(window);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Requests user attention to the specified window.
     *
     *  This function requests user attention to the specified window.  On
     *  platforms where this is not supported, attention is requested to the
     *  application as a whole.
     *
     *  Once the user has given attention, usually by focusing the window or
     *  application, the system will end the request automatically.
     *
     *  @param[in] window The window to request attention to.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @remark @macos Attention is requested to the application as a whole, not the
     *  specific window.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_attention
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup window
     */
    public static void glfwRequestWindowAttention(java.lang.foreign.MemorySegment window)
    {
        try {MTD$glfwRequestWindowAttention.invokeExact(window);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the monitor that the window uses for full screen mode.
     *
     *  This function returns the handle of the monitor that the specified window is
     *  in full screen on.
     *
     *  @param[in] window The window to query.
     *  @return The monitor, or `NULL` if the window is in windowed mode or an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_monitor
     *  @sa @ref glfwSetWindowMonitor
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup window
     */
    public static java.lang.foreign.MemorySegment glfwGetWindowMonitor(java.lang.foreign.MemorySegment window)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetWindowMonitor.invokeExact(window);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the mode, monitor, video mode and placement of a window.
     *
     *  This function sets the monitor that the window uses for full screen mode or,
     *  if the monitor is `NULL`, makes it windowed mode.
     *
     *  When setting a monitor, this function updates the width, height and refresh
     *  rate of the desired video mode and switches to the video mode closest to it.
     *  The window position is ignored when setting a monitor.
     *
     *  When the monitor is `NULL`, the position, width and height are used to
     *  place the window content area.  The refresh rate is ignored when no monitor
     *  is specified.
     *
     *  If you only wish to update the resolution of a full screen window or the
     *  size of a windowed mode window, see @ref glfwSetWindowSize.
     *
     *  When a window transitions from full screen to windowed mode, this function
     *  restores any previous window settings such as whether it is decorated,
     *  floating, resizable, has size or aspect ratio limits, etc.
     *
     *  @param[in] window The window whose monitor, size or video mode to set.
     *  @param[in] monitor The desired monitor, or `NULL` to set windowed mode.
     *  @param[in] xpos The desired x-coordinate of the upper-left corner of the
     *  content area.
     *  @param[in] ypos The desired y-coordinate of the upper-left corner of the
     *  content area.
     *  @param[in] width The desired with, in screen coordinates, of the content
     *  area or video mode.
     *  @param[in] height The desired height, in screen coordinates, of the content
     *  area or video mode.
     *  @param[in] refreshRate The desired refresh rate, in Hz, of the video mode,
     *  or `GLFW_DONT_CARE`.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @remark The OpenGL or OpenGL ES context will not be destroyed or otherwise
     *  affected by any resizing or mode switching, although you may need to update
     *  your viewport if the framebuffer size has changed.
     *
     *  @remark @wayland The desired window position is ignored, as there is no way
     *  for an application to set this property.
     *
     *  @remark @wayland Setting the window to full screen will not attempt to
     *  change the mode, no matter what the requested size or refresh rate.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_monitor
     *  @sa @ref window_full_screen
     *  @sa @ref glfwGetWindowMonitor
     *  @sa @ref glfwSetWindowSize
     *
     *  @since Added in version 3.2.
     *
     *  @ingroup window
     */
    public static void glfwSetWindowMonitor(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment monitor, int xpos, int ypos, int width, int height, int refreshRate)
    {
        try {MTD$glfwSetWindowMonitor.invokeExact(window, monitor, xpos, ypos, width, height, refreshRate);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns an attribute of the specified window.
     *
     *  This function returns the value of an attribute of the specified window or
     *  its OpenGL or OpenGL ES context.
     *
     *  @param[in] window The window to query.
     *  @param[in] attrib The [window attribute](@ref window_attribs) whose value to
     *  return.
     *  @return The value of the attribute, or zero if an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
     *
     *  @remark Framebuffer related hints are not window attributes.  See @ref
     *  window_attribs_fb for more information.
     *
     *  @remark Zero is a valid value for many window and context related
     *  attributes so you cannot use a return value of zero as an indication of
     *  errors.  However, this function should not fail as long as it is passed
     *  valid arguments and the library has been [initialized](@ref intro_init).
     *
     *  @remark @wayland The Wayland protocol provides no way to check whether a
     *  window is iconfied, so @ref GLFW_ICONIFIED always returns `GLFW_FALSE`.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_attribs
     *  @sa @ref glfwSetWindowAttrib
     *
     *  @since Added in version 3.0.  Replaces `glfwGetWindowParam` and
     *  `glfwGetGLVersion`.
     *
     *  @ingroup window
     */
    public static int glfwGetWindowAttrib(java.lang.foreign.MemorySegment window, int attrib)
    {
        try {return (int)MTD$glfwGetWindowAttrib.invokeExact(window, attrib);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets an attribute of the specified window.
     *
     *  This function sets the value of an attribute of the specified window.
     *
     *  The supported attributes are [GLFW_DECORATED](@ref GLFW_DECORATED_attrib),
     *  [GLFW_RESIZABLE](@ref GLFW_RESIZABLE_attrib),
     *  [GLFW_FLOATING](@ref GLFW_FLOATING_attrib),
     *  [GLFW_AUTO_ICONIFY](@ref GLFW_AUTO_ICONIFY_attrib) and
     *  [GLFW_FOCUS_ON_SHOW](@ref GLFW_FOCUS_ON_SHOW_attrib).
     *
     *  Some of these attributes are ignored for full screen windows.  The new
     *  value will take effect if the window is later made windowed.
     *
     *  Some of these attributes are ignored for windowed mode windows.  The new
     *  value will take effect if the window is later made full screen.
     *
     *  @param[in] window The window to set the attribute for.
     *  @param[in] attrib A supported window attribute.
     *  @param[in] value `GLFW_TRUE` or `GLFW_FALSE`.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_INVALID_ENUM, @ref GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.
     *
     *  @remark Calling @ref glfwGetWindowAttrib will always return the latest
     *  value, even if that value is ignored by the current mode of the window.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_attribs
     *  @sa @ref glfwGetWindowAttrib
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup window
     */
    public static void glfwSetWindowAttrib(java.lang.foreign.MemorySegment window, int attrib, int value)
    {
        try {MTD$glfwSetWindowAttrib.invokeExact(window, attrib, value);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the user pointer of the specified window.
     *
     *  This function sets the user-defined pointer of the specified window.  The
     *  current value is retained until the window is destroyed.  The initial value
     *  is `NULL`.
     *
     *  @param[in] window The window whose pointer to set.
     *  @param[in] pointer The new value.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function may be called from any thread.  Access is not
     *  synchronized.
     *
     *  @sa @ref window_userptr
     *  @sa @ref glfwGetWindowUserPointer
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup window
     */
    public static void glfwSetWindowUserPointer(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment pointer)
    {
        try {MTD$glfwSetWindowUserPointer.invokeExact(window, pointer);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the user pointer of the specified window.
     *
     *  This function returns the current value of the user-defined pointer of the
     *  specified window.  The initial value is `NULL`.
     *
     *  @param[in] window The window whose pointer to return.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function may be called from any thread.  Access is not
     *  synchronized.
     *
     *  @sa @ref window_userptr
     *  @sa @ref glfwSetWindowUserPointer
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup window
     */
    public static java.lang.foreign.MemorySegment glfwGetWindowUserPointer(java.lang.foreign.MemorySegment window)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetWindowUserPointer.invokeExact(window);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the position callback for the specified window.
     *
     *  This function sets the position callback of the specified window, which is
     *  called when the window is moved.  The callback is provided with the
     *  position, in screen coordinates, of the upper-left corner of the content
     *  area of the window.
     *
     *  @param[in] window The window whose callback to set.
     *  @param[in] callback The new callback, or `NULL` to remove the currently set
     *  callback.
     *  @return The previously set callback, or `NULL` if no callback was set or the
     *  library had not been [initialized](@ref intro_init).
     *
     *  @callback_signature
     *  @code
     *  void function_name(GLFWwindow* window, int xpos, int ypos)
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [function pointer type](@ref GLFWwindowposfun).
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @remark @wayland This callback will never be called, as there is no way for
     *  an application to know its global position.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_pos
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup window
     */
    public static java.lang.foreign.MemorySegment glfwSetWindowPosCallback(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetWindowPosCallback.invokeExact(window, callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the size callback for the specified window.
     *
     *  This function sets the size callback of the specified window, which is
     *  called when the window is resized.  The callback is provided with the size,
     *  in screen coordinates, of the content area of the window.
     *
     *  @param[in] window The window whose callback to set.
     *  @param[in] callback The new callback, or `NULL` to remove the currently set
     *  callback.
     *  @return The previously set callback, or `NULL` if no callback was set or the
     *  library had not been [initialized](@ref intro_init).
     *
     *  @callback_signature
     *  @code
     *  void function_name(GLFWwindow* window, int width, int height)
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [function pointer type](@ref GLFWwindowsizefun).
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_size
     *
     *  @since Added in version 1.0.
     *  @glfw3 Added window handle parameter and return value.
     *
     *  @ingroup window
     */
    public static java.lang.foreign.MemorySegment glfwSetWindowSizeCallback(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetWindowSizeCallback.invokeExact(window, callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the close callback for the specified window.
     *
     *  This function sets the close callback of the specified window, which is
     *  called when the user attempts to close the window, for example by clicking
     *  the close widget in the title bar.
     *
     *  The close flag is set before this callback is called, but you can modify it
     *  at any time with @ref glfwSetWindowShouldClose.
     *
     *  The close callback is not triggered by @ref glfwDestroyWindow.
     *
     *  @param[in] window The window whose callback to set.
     *  @param[in] callback The new callback, or `NULL` to remove the currently set
     *  callback.
     *  @return The previously set callback, or `NULL` if no callback was set or the
     *  library had not been [initialized](@ref intro_init).
     *
     *  @callback_signature
     *  @code
     *  void function_name(GLFWwindow* window)
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [function pointer type](@ref GLFWwindowclosefun).
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @remark @macos Selecting Quit from the application menu will trigger the
     *  close callback for all windows.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_close
     *
     *  @since Added in version 2.5.
     *  @glfw3 Added window handle parameter and return value.
     *
     *  @ingroup window
     */
    public static java.lang.foreign.MemorySegment glfwSetWindowCloseCallback(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetWindowCloseCallback.invokeExact(window, callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the refresh callback for the specified window.
     *
     *  This function sets the refresh callback of the specified window, which is
     *  called when the content area of the window needs to be redrawn, for example
     *  if the window has been exposed after having been covered by another window.
     *
     *  On compositing window systems such as Aero, Compiz, Aqua or Wayland, where
     *  the window contents are saved off-screen, this callback may be called only
     *  very infrequently or never at all.
     *
     *  @param[in] window The window whose callback to set.
     *  @param[in] callback The new callback, or `NULL` to remove the currently set
     *  callback.
     *  @return The previously set callback, or `NULL` if no callback was set or the
     *  library had not been [initialized](@ref intro_init).
     *
     *  @callback_signature
     *  @code
     *  void function_name(GLFWwindow* window);
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [function pointer type](@ref GLFWwindowrefreshfun).
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_refresh
     *
     *  @since Added in version 2.5.
     *  @glfw3 Added window handle parameter and return value.
     *
     *  @ingroup window
     */
    public static java.lang.foreign.MemorySegment glfwSetWindowRefreshCallback(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetWindowRefreshCallback.invokeExact(window, callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the focus callback for the specified window.
     *
     *  This function sets the focus callback of the specified window, which is
     *  called when the window gains or loses input focus.
     *
     *  After the focus callback is called for a window that lost input focus,
     *  synthetic key and mouse button release events will be generated for all such
     *  that had been pressed.  For more information, see @ref glfwSetKeyCallback
     *  and @ref glfwSetMouseButtonCallback.
     *
     *  @param[in] window The window whose callback to set.
     *  @param[in] callback The new callback, or `NULL` to remove the currently set
     *  callback.
     *  @return The previously set callback, or `NULL` if no callback was set or the
     *  library had not been [initialized](@ref intro_init).
     *
     *  @callback_signature
     *  @code
     *  void function_name(GLFWwindow* window, int focused)
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [function pointer type](@ref GLFWwindowfocusfun).
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_focus
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup window
     */
    public static java.lang.foreign.MemorySegment glfwSetWindowFocusCallback(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetWindowFocusCallback.invokeExact(window, callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the iconify callback for the specified window.
     *
     *  This function sets the iconification callback of the specified window, which
     *  is called when the window is iconified or restored.
     *
     *  @param[in] window The window whose callback to set.
     *  @param[in] callback The new callback, or `NULL` to remove the currently set
     *  callback.
     *  @return The previously set callback, or `NULL` if no callback was set or the
     *  library had not been [initialized](@ref intro_init).
     *
     *  @callback_signature
     *  @code
     *  void function_name(GLFWwindow* window, int iconified)
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [function pointer type](@ref GLFWwindowiconifyfun).
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @remark @wayland The XDG-shell protocol has no event for iconification, so
     *  this callback will never be called.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_iconify
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup window
     */
    public static java.lang.foreign.MemorySegment glfwSetWindowIconifyCallback(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetWindowIconifyCallback.invokeExact(window, callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the maximize callback for the specified window.
     *
     *  This function sets the maximization callback of the specified window, which
     *  is called when the window is maximized or restored.
     *
     *  @param[in] window The window whose callback to set.
     *  @param[in] callback The new callback, or `NULL` to remove the currently set
     *  callback.
     *  @return The previously set callback, or `NULL` if no callback was set or the
     *  library had not been [initialized](@ref intro_init).
     *
     *  @callback_signature
     *  @code
     *  void function_name(GLFWwindow* window, int maximized)
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [function pointer type](@ref GLFWwindowmaximizefun).
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_maximize
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup window
     */
    public static java.lang.foreign.MemorySegment glfwSetWindowMaximizeCallback(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetWindowMaximizeCallback.invokeExact(window, callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the framebuffer resize callback for the specified window.
     *
     *  This function sets the framebuffer resize callback of the specified window,
     *  which is called when the framebuffer of the specified window is resized.
     *
     *  @param[in] window The window whose callback to set.
     *  @param[in] callback The new callback, or `NULL` to remove the currently set
     *  callback.
     *  @return The previously set callback, or `NULL` if no callback was set or the
     *  library had not been [initialized](@ref intro_init).
     *
     *  @callback_signature
     *  @code
     *  void function_name(GLFWwindow* window, int width, int height)
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [function pointer type](@ref GLFWframebuffersizefun).
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_fbsize
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup window
     */
    public static java.lang.foreign.MemorySegment glfwSetFramebufferSizeCallback(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetFramebufferSizeCallback.invokeExact(window, callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the window content scale callback for the specified window.
     *
     *  This function sets the window content scale callback of the specified window,
     *  which is called when the content scale of the specified window changes.
     *
     *  @param[in] window The window whose callback to set.
     *  @param[in] callback The new callback, or `NULL` to remove the currently set
     *  callback.
     *  @return The previously set callback, or `NULL` if no callback was set or the
     *  library had not been [initialized](@ref intro_init).
     *
     *  @callback_signature
     *  @code
     *  void function_name(GLFWwindow* window, float xscale, float yscale)
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [function pointer type](@ref GLFWwindowcontentscalefun).
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref window_scale
     *  @sa @ref glfwGetWindowContentScale
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup window
     */
    public static java.lang.foreign.MemorySegment glfwSetWindowContentScaleCallback(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetWindowContentScaleCallback.invokeExact(window, callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Processes all pending events.
     *
     *  This function processes only those events that are already in the event
     *  queue and then returns immediately.  Processing events will cause the window
     *  and input callbacks associated with those events to be called.
     *
     *  On some platforms, a window move, resize or menu operation will cause event
     *  processing to block.  This is due to how event processing is designed on
     *  those platforms.  You can use the
     *  [window refresh callback](@ref window_refresh) to redraw the contents of
     *  your window when necessary during such operations.
     *
     *  Do not assume that callbacks you set will _only_ be called in response to
     *  event processing functions like this one.  While it is necessary to poll for
     *  events, window systems that require GLFW to register callbacks of its own
     *  can pass events to GLFW in response to many window system function calls.
     *  GLFW will pass those events on to the application callbacks before
     *  returning.
     *
     *  Event processing is not required for joystick input to work.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @reentrancy This function must not be called from a callback.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref events
     *  @sa @ref glfwWaitEvents
     *  @sa @ref glfwWaitEventsTimeout
     *
     *  @since Added in version 1.0.
     *
     *  @ingroup window
     */
    public static void glfwPollEvents()
    {
        try {MTD$glfwPollEvents.invokeExact();}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Waits until events are queued and processes them.
     *
     *  This function puts the calling thread to sleep until at least one event is
     *  available in the event queue.  Once one or more events are available,
     *  it behaves exactly like @ref glfwPollEvents, i.e. the events in the queue
     *  are processed and the function then returns immediately.  Processing events
     *  will cause the window and input callbacks associated with those events to be
     *  called.
     *
     *  Since not all events are associated with callbacks, this function may return
     *  without a callback having been called even if you are monitoring all
     *  callbacks.
     *
     *  On some platforms, a window move, resize or menu operation will cause event
     *  processing to block.  This is due to how event processing is designed on
     *  those platforms.  You can use the
     *  [window refresh callback](@ref window_refresh) to redraw the contents of
     *  your window when necessary during such operations.
     *
     *  Do not assume that callbacks you set will _only_ be called in response to
     *  event processing functions like this one.  While it is necessary to poll for
     *  events, window systems that require GLFW to register callbacks of its own
     *  can pass events to GLFW in response to many window system function calls.
     *  GLFW will pass those events on to the application callbacks before
     *  returning.
     *
     *  Event processing is not required for joystick input to work.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @reentrancy This function must not be called from a callback.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref events
     *  @sa @ref glfwPollEvents
     *  @sa @ref glfwWaitEventsTimeout
     *
     *  @since Added in version 2.5.
     *
     *  @ingroup window
     */
    public static void glfwWaitEvents()
    {
        try {MTD$glfwWaitEvents.invokeExact();}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Waits with timeout until events are queued and processes them.
     *
     *  This function puts the calling thread to sleep until at least one event is
     *  available in the event queue, or until the specified timeout is reached.  If
     *  one or more events are available, it behaves exactly like @ref
     *  glfwPollEvents, i.e. the events in the queue are processed and the function
     *  then returns immediately.  Processing events will cause the window and input
     *  callbacks associated with those events to be called.
     *
     *  The timeout value must be a positive finite number.
     *
     *  Since not all events are associated with callbacks, this function may return
     *  without a callback having been called even if you are monitoring all
     *  callbacks.
     *
     *  On some platforms, a window move, resize or menu operation will cause event
     *  processing to block.  This is due to how event processing is designed on
     *  those platforms.  You can use the
     *  [window refresh callback](@ref window_refresh) to redraw the contents of
     *  your window when necessary during such operations.
     *
     *  Do not assume that callbacks you set will _only_ be called in response to
     *  event processing functions like this one.  While it is necessary to poll for
     *  events, window systems that require GLFW to register callbacks of its own
     *  can pass events to GLFW in response to many window system function calls.
     *  GLFW will pass those events on to the application callbacks before
     *  returning.
     *
     *  Event processing is not required for joystick input to work.
     *
     *  @param[in] timeout The maximum amount of time, in seconds, to wait.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.
     *
     *  @reentrancy This function must not be called from a callback.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref events
     *  @sa @ref glfwPollEvents
     *  @sa @ref glfwWaitEvents
     *
     *  @since Added in version 3.2.
     *
     *  @ingroup window
     */
    public static void glfwWaitEventsTimeout(double timeout)
    {
        try {MTD$glfwWaitEventsTimeout.invokeExact(timeout);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Posts an empty event to the event queue.
     *
     *  This function posts an empty event from the current thread to the event
     *  queue, causing @ref glfwWaitEvents or @ref glfwWaitEventsTimeout to return.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function may be called from any thread.
     *
     *  @sa @ref events
     *  @sa @ref glfwWaitEvents
     *  @sa @ref glfwWaitEventsTimeout
     *
     *  @since Added in version 3.1.
     *
     *  @ingroup window
     */
    public static void glfwPostEmptyEvent()
    {
        try {MTD$glfwPostEmptyEvent.invokeExact();}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the value of an input option for the specified window.
     *
     *  This function returns the value of an input option for the specified window.
     *  The mode must be one of @ref GLFW_CURSOR, @ref GLFW_STICKY_KEYS,
     *  @ref GLFW_STICKY_MOUSE_BUTTONS, @ref GLFW_LOCK_KEY_MODS or
     *  @ref GLFW_RAW_MOUSE_MOTION.
     *
     *  @param[in] window The window to query.
     *  @param[in] mode One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS`,
     *  `GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS` or
     *  `GLFW_RAW_MOUSE_MOTION`.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_INVALID_ENUM.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref glfwSetInputMode
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup input
     */
    public static int glfwGetInputMode(java.lang.foreign.MemorySegment window, int mode)
    {
        try {return (int)MTD$glfwGetInputMode.invokeExact(window, mode);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets an input option for the specified window.
     *
     *  This function sets an input mode option for the specified window.  The mode
     *  must be one of @ref GLFW_CURSOR, @ref GLFW_STICKY_KEYS,
     *  @ref GLFW_STICKY_MOUSE_BUTTONS, @ref GLFW_LOCK_KEY_MODS or
     *  @ref GLFW_RAW_MOUSE_MOTION.
     *
     *  If the mode is `GLFW_CURSOR`, the value must be one of the following cursor
     *  modes:
     *  - `GLFW_CURSOR_NORMAL` makes the cursor visible and behaving normally.
     *  - `GLFW_CURSOR_HIDDEN` makes the cursor invisible when it is over the
     *    content area of the window but does not restrict the cursor from leaving.
     *  - `GLFW_CURSOR_DISABLED` hides and grabs the cursor, providing virtual
     *    and unlimited cursor movement.  This is useful for implementing for
     *    example 3D camera controls.
     *
     *  If the mode is `GLFW_STICKY_KEYS`, the value must be either `GLFW_TRUE` to
     *  enable sticky keys, or `GLFW_FALSE` to disable it.  If sticky keys are
     *  enabled, a key press will ensure that @ref glfwGetKey returns `GLFW_PRESS`
     *  the next time it is called even if the key had been released before the
     *  call.  This is useful when you are only interested in whether keys have been
     *  pressed but not when or in which order.
     *
     *  If the mode is `GLFW_STICKY_MOUSE_BUTTONS`, the value must be either
     *  `GLFW_TRUE` to enable sticky mouse buttons, or `GLFW_FALSE` to disable it.
     *  If sticky mouse buttons are enabled, a mouse button press will ensure that
     *  @ref glfwGetMouseButton returns `GLFW_PRESS` the next time it is called even
     *  if the mouse button had been released before the call.  This is useful when
     *  you are only interested in whether mouse buttons have been pressed but not
     *  when or in which order.
     *
     *  If the mode is `GLFW_LOCK_KEY_MODS`, the value must be either `GLFW_TRUE` to
     *  enable lock key modifier bits, or `GLFW_FALSE` to disable them.  If enabled,
     *  callbacks that receive modifier bits will also have the @ref
     *  GLFW_MOD_CAPS_LOCK bit set when the event was generated with Caps Lock on,
     *  and the @ref GLFW_MOD_NUM_LOCK bit when Num Lock was on.
     *
     *  If the mode is `GLFW_RAW_MOUSE_MOTION`, the value must be either `GLFW_TRUE`
     *  to enable raw (unscaled and unaccelerated) mouse motion when the cursor is
     *  disabled, or `GLFW_FALSE` to disable it.  If raw motion is not supported,
     *  attempting to set this will emit @ref GLFW_PLATFORM_ERROR.  Call @ref
     *  glfwRawMouseMotionSupported to check for support.
     *
     *  @param[in] window The window whose input mode to set.
     *  @param[in] mode One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS`,
     *  `GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS` or
     *  `GLFW_RAW_MOUSE_MOTION`.
     *  @param[in] value The new value of the specified input mode.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref glfwGetInputMode
     *
     *  @since Added in version 3.0.  Replaces `glfwEnable` and `glfwDisable`.
     *
     *  @ingroup input
     */
    public static void glfwSetInputMode(java.lang.foreign.MemorySegment window, int mode, int value)
    {
        try {MTD$glfwSetInputMode.invokeExact(window, mode, value);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns whether raw mouse motion is supported.
     *
     *  This function returns whether raw mouse motion is supported on the current
     *  system.  This status does not change after GLFW has been initialized so you
     *  only need to check this once.  If you attempt to enable raw motion on
     *  a system that does not support it, @ref GLFW_PLATFORM_ERROR will be emitted.
     *
     *  Raw mouse motion is closer to the actual motion of the mouse across
     *  a surface.  It is not affected by the scaling and acceleration applied to
     *  the motion of the desktop cursor.  That processing is suitable for a cursor
     *  while raw motion is better for controlling for example a 3D camera.  Because
     *  of this, raw mouse motion is only provided when the cursor is disabled.
     *
     *  @return `GLFW_TRUE` if raw mouse motion is supported on the current machine,
     *  or `GLFW_FALSE` otherwise.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref raw_mouse_motion
     *  @sa @ref glfwSetInputMode
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup input
     */
    public static int glfwRawMouseMotionSupported()
    {
        try {return (int)MTD$glfwRawMouseMotionSupported.invokeExact();}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the layout-specific name of the specified printable key.
     *
     *  This function returns the name of the specified printable key, encoded as
     *  UTF-8.  This is typically the character that key would produce without any
     *  modifier keys, intended for displaying key bindings to the user.  For dead
     *  keys, it is typically the diacritic it would add to a character.
     *
     *  __Do not use this function__ for [text input](@ref input_char).  You will
     *  break text input for many languages even if it happens to work for yours.
     *
     *  If the key is `GLFW_KEY_UNKNOWN`, the scancode is used to identify the key,
     *  otherwise the scancode is ignored.  If you specify a non-printable key, or
     *  `GLFW_KEY_UNKNOWN` and a scancode that maps to a non-printable key, this
     *  function returns `NULL` but does not emit an error.
     *
     *  This behavior allows you to always pass in the arguments in the
     *  [key callback](@ref input_key) without modification.
     *
     *  The printable keys are:
     *  - `GLFW_KEY_APOSTROPHE`
     *  - `GLFW_KEY_COMMA`
     *  - `GLFW_KEY_MINUS`
     *  - `GLFW_KEY_PERIOD`
     *  - `GLFW_KEY_SLASH`
     *  - `GLFW_KEY_SEMICOLON`
     *  - `GLFW_KEY_EQUAL`
     *  - `GLFW_KEY_LEFT_BRACKET`
     *  - `GLFW_KEY_RIGHT_BRACKET`
     *  - `GLFW_KEY_BACKSLASH`
     *  - `GLFW_KEY_WORLD_1`
     *  - `GLFW_KEY_WORLD_2`
     *  - `GLFW_KEY_0` to `GLFW_KEY_9`
     *  - `GLFW_KEY_A` to `GLFW_KEY_Z`
     *  - `GLFW_KEY_KP_0` to `GLFW_KEY_KP_9`
     *  - `GLFW_KEY_KP_DECIMAL`
     *  - `GLFW_KEY_KP_DIVIDE`
     *  - `GLFW_KEY_KP_MULTIPLY`
     *  - `GLFW_KEY_KP_SUBTRACT`
     *  - `GLFW_KEY_KP_ADD`
     *  - `GLFW_KEY_KP_EQUAL`
     *
     *  Names for printable keys depend on keyboard layout, while names for
     *  non-printable keys are the same across layouts but depend on the application
     *  language and should be localized along with other user interface text.
     *
     *  @param[in] key The key to query, or `GLFW_KEY_UNKNOWN`.
     *  @param[in] scancode The scancode of the key to query.
     *  @return The UTF-8 encoded, layout-specific name of the key, or `NULL`.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_INVALID_VALUE, @ref GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
     *
     *  @remark The contents of the returned string may change when a keyboard
     *  layout change event is received.
     *
     *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You
     *  should not free it yourself.  It is valid until the library is terminated.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref input_key_name
     *
     *  @since Added in version 3.2.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwGetKeyName(int key, int scancode)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetKeyName.invokeExact(key, scancode);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the platform-specific scancode of the specified key.
     *
     *  This function returns the platform-specific scancode of the specified key.
     *
     *  If the specified [key token](@ref keys) corresponds to a physical key not
     *  supported on the current platform then this method will return `-1`.
     *  Calling this function with anything other than a key token will return `-1`
     *  and generate a @ref GLFW_INVALID_ENUM error.
     *
     *  @param[in] key Any [key token](@ref keys).
     *  @return The platform-specific scancode for the key, or `-1` if the key is
     *  not supported on the current platform or an [error](@ref error_handling)
     *  occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_INVALID_ENUM.
     *
     *  @thread_safety This function may be called from any thread.
     *
     *  @sa @ref input_key
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup input
     */
    public static int glfwGetKeyScancode(int key)
    {
        try {return (int)MTD$glfwGetKeyScancode.invokeExact(key);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the last reported state of a keyboard key for the specified
     *  window.
     *
     *  This function returns the last state reported for the specified key to the
     *  specified window.  The returned state is one of `GLFW_PRESS` or
     *  `GLFW_RELEASE`.  The action `GLFW_REPEAT` is only reported to the key callback.
     *
     *  If the @ref GLFW_STICKY_KEYS input mode is enabled, this function returns
     *  `GLFW_PRESS` the first time you call it for a key that was pressed, even if
     *  that key has already been released.
     *
     *  The key functions deal with physical keys, with [key tokens](@ref keys)
     *  named after their use on the standard US keyboard layout.  If you want to
     *  input text, use the Unicode character callback instead.
     *
     *  The [modifier key bit masks](@ref mods) are not key tokens and cannot be
     *  used with this function.
     *
     *  __Do not use this function__ to implement [text input](@ref input_char).
     *
     *  @param[in] window The desired window.
     *  @param[in] key The desired [keyboard key](@ref keys).  `GLFW_KEY_UNKNOWN` is
     *  not a valid key for this function.
     *  @return One of `GLFW_PRESS` or `GLFW_RELEASE`.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_INVALID_ENUM.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref input_key
     *
     *  @since Added in version 1.0.
     *  @glfw3 Added window handle parameter.
     *
     *  @ingroup input
     */
    public static int glfwGetKey(java.lang.foreign.MemorySegment window, int key)
    {
        try {return (int)MTD$glfwGetKey.invokeExact(window, key);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the last reported state of a mouse button for the specified
     *  window.
     *
     *  This function returns the last state reported for the specified mouse button
     *  to the specified window.  The returned state is one of `GLFW_PRESS` or
     *  `GLFW_RELEASE`.
     *
     *  If the @ref GLFW_STICKY_MOUSE_BUTTONS input mode is enabled, this function
     *  returns `GLFW_PRESS` the first time you call it for a mouse button that was
     *  pressed, even if that mouse button has already been released.
     *
     *  @param[in] window The desired window.
     *  @param[in] button The desired [mouse button](@ref buttons).
     *  @return One of `GLFW_PRESS` or `GLFW_RELEASE`.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_INVALID_ENUM.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref input_mouse_button
     *
     *  @since Added in version 1.0.
     *  @glfw3 Added window handle parameter.
     *
     *  @ingroup input
     */
    public static int glfwGetMouseButton(java.lang.foreign.MemorySegment window, int button)
    {
        try {return (int)MTD$glfwGetMouseButton.invokeExact(window, button);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Retrieves the position of the cursor relative to the content area of
     *  the window.
     *
     *  This function returns the position of the cursor, in screen coordinates,
     *  relative to the upper-left corner of the content area of the specified
     *  window.
     *
     *  If the cursor is disabled (with `GLFW_CURSOR_DISABLED`) then the cursor
     *  position is unbounded and limited only by the minimum and maximum values of
     *  a `double`.
     *
     *  The coordinate can be converted to their integer equivalents with the
     *  `floor` function.  Casting directly to an integer type works for positive
     *  coordinates, but fails for negative ones.
     *
     *  Any or all of the position arguments may be `NULL`.  If an error occurs, all
     *  non-`NULL` position arguments will be set to zero.
     *
     *  @param[in] window The desired window.
     *  @param[out] xpos Where to store the cursor x-coordinate, relative to the
     *  left edge of the content area, or `NULL`.
     *  @param[out] ypos Where to store the cursor y-coordinate, relative to the to
     *  top edge of the content area, or `NULL`.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref cursor_pos
     *  @sa @ref glfwSetCursorPos
     *
     *  @since Added in version 3.0.  Replaces `glfwGetMousePos`.
     *
     *  @ingroup input
     */
    public static void glfwGetCursorPos(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment xpos, java.lang.foreign.MemorySegment ypos)
    {
        try {MTD$glfwGetCursorPos.invokeExact(window, xpos, ypos);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the position of the cursor, relative to the content area of the
     *  window.
     *
     *  This function sets the position, in screen coordinates, of the cursor
     *  relative to the upper-left corner of the content area of the specified
     *  window.  The window must have input focus.  If the window does not have
     *  input focus when this function is called, it fails silently.
     *
     *  __Do not use this function__ to implement things like camera controls.  GLFW
     *  already provides the `GLFW_CURSOR_DISABLED` cursor mode that hides the
     *  cursor, transparently re-centers it and provides unconstrained cursor
     *  motion.  See @ref glfwSetInputMode for more information.
     *
     *  If the cursor mode is `GLFW_CURSOR_DISABLED` then the cursor position is
     *  unconstrained and limited only by the minimum and maximum values of
     *  a `double`.
     *
     *  @param[in] window The desired window.
     *  @param[in] xpos The desired x-coordinate, relative to the left edge of the
     *  content area.
     *  @param[in] ypos The desired y-coordinate, relative to the top edge of the
     *  content area.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @remark @wayland This function will only work when the cursor mode is
     *  `GLFW_CURSOR_DISABLED`, otherwise it will do nothing.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref cursor_pos
     *  @sa @ref glfwGetCursorPos
     *
     *  @since Added in version 3.0.  Replaces `glfwSetMousePos`.
     *
     *  @ingroup input
     */
    public static void glfwSetCursorPos(java.lang.foreign.MemorySegment window, double xpos, double ypos)
    {
        try {MTD$glfwSetCursorPos.invokeExact(window, xpos, ypos);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Creates a custom cursor.
     *
     *  Creates a new custom cursor image that can be set for a window with @ref
     *  glfwSetCursor.  The cursor can be destroyed with @ref glfwDestroyCursor.
     *  Any remaining cursors are destroyed by @ref glfwTerminate.
     *
     *  The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight
     *  bits per channel with the red channel first.  They are arranged canonically
     *  as packed sequential rows, starting from the top-left corner.
     *
     *  The cursor hotspot is specified in pixels, relative to the upper-left corner
     *  of the cursor image.  Like all other coordinate systems in GLFW, the X-axis
     *  points to the right and the Y-axis points down.
     *
     *  @param[in] image The desired cursor image.
     *  @param[in] xhot The desired x-coordinate, in pixels, of the cursor hotspot.
     *  @param[in] yhot The desired y-coordinate, in pixels, of the cursor hotspot.
     *  @return The handle of the created cursor, or `NULL` if an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.
     *
     *  @pointer_lifetime The specified image data is copied before this function
     *  returns.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref cursor_object
     *  @sa @ref glfwDestroyCursor
     *  @sa @ref glfwCreateStandardCursor
     *
     *  @since Added in version 3.1.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwCreateCursor(java.lang.foreign.MemorySegment image, int xhot, int yhot)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwCreateCursor.invokeExact(image, xhot, yhot);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Creates a cursor with a standard shape.
     *
     *  Returns a cursor with a [standard shape](@ref shapes), that can be set for
     *  a window with @ref glfwSetCursor.
     *
     *  @param[in] shape One of the [standard shapes](@ref shapes).
     *  @return A new cursor ready to use or `NULL` if an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref cursor_object
     *  @sa @ref glfwCreateCursor
     *
     *  @since Added in version 3.1.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwCreateStandardCursor(int shape)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwCreateStandardCursor.invokeExact(shape);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Destroys a cursor.
     *
     *  This function destroys a cursor previously created with @ref
     *  glfwCreateCursor.  Any remaining cursors will be destroyed by @ref
     *  glfwTerminate.
     *
     *  If the specified cursor is current for any window, that window will be
     *  reverted to the default cursor.  This does not affect the cursor mode.
     *
     *  @param[in] cursor The cursor object to destroy.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @reentrancy This function must not be called from a callback.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref cursor_object
     *  @sa @ref glfwCreateCursor
     *
     *  @since Added in version 3.1.
     *
     *  @ingroup input
     */
    public static void glfwDestroyCursor(java.lang.foreign.MemorySegment cursor)
    {
        try {MTD$glfwDestroyCursor.invokeExact(cursor);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the cursor for the window.
     *
     *  This function sets the cursor image to be used when the cursor is over the
     *  content area of the specified window.  The set cursor will only be visible
     *  when the [cursor mode](@ref cursor_mode) of the window is
     *  `GLFW_CURSOR_NORMAL`.
     *
     *  On some platforms, the set cursor may not be visible unless the window also
     *  has input focus.
     *
     *  @param[in] window The window to set the cursor for.
     *  @param[in] cursor The cursor to set, or `NULL` to switch back to the default
     *  arrow cursor.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref cursor_object
     *
     *  @since Added in version 3.1.
     *
     *  @ingroup input
     */
    public static void glfwSetCursor(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment cursor)
    {
        try {MTD$glfwSetCursor.invokeExact(window, cursor);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the key callback.
     *
     *  This function sets the key callback of the specified window, which is called
     *  when a key is pressed, repeated or released.
     *
     *  The key functions deal with physical keys, with layout independent
     *  [key tokens](@ref keys) named after their values in the standard US keyboard
     *  layout.  If you want to input text, use the
     *  [character callback](@ref glfwSetCharCallback) instead.
     *
     *  When a window loses input focus, it will generate synthetic key release
     *  events for all pressed keys with associated key tokens.  You can tell these
     *  events from user-generated events by the fact that the synthetic ones are
     *  generated after the focus loss event has been processed, i.e. after the
     *  [window focus callback](@ref glfwSetWindowFocusCallback) has been called.
     *
     *  The scancode of a key is specific to that platform or sometimes even to that
     *  machine.  Scancodes are intended to allow users to bind keys that don't have
     *  a GLFW key token.  Such keys have `key` set to `GLFW_KEY_UNKNOWN`, their
     *  state is not saved and so it cannot be queried with @ref glfwGetKey.
     *
     *  Sometimes GLFW needs to generate synthetic key events, in which case the
     *  scancode may be zero.
     *
     *  @param[in] window The window whose callback to set.
     *  @param[in] callback The new key callback, or `NULL` to remove the currently
     *  set callback.
     *  @return The previously set callback, or `NULL` if no callback was set or the
     *  library had not been [initialized](@ref intro_init).
     *
     *  @callback_signature
     *  @code
     *  void function_name(GLFWwindow* window, int key, int scancode, int action, int mods)
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [function pointer type](@ref GLFWkeyfun).
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref input_key
     *
     *  @since Added in version 1.0.
     *  @glfw3 Added window handle parameter and return value.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwSetKeyCallback(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetKeyCallback.invokeExact(window, callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the Unicode character callback.
     *
     *  This function sets the character callback of the specified window, which is
     *  called when a Unicode character is input.
     *
     *  The character callback is intended for Unicode text input.  As it deals with
     *  characters, it is keyboard layout dependent, whereas the
     *  [key callback](@ref glfwSetKeyCallback) is not.  Characters do not map 1:1
     *  to physical keys, as a key may produce zero, one or more characters.  If you
     *  want to know whether a specific physical key was pressed or released, see
     *  the key callback instead.
     *
     *  The character callback behaves as system text input normally does and will
     *  not be called if modifier keys are held down that would prevent normal text
     *  input on that platform, for example a Super (Command) key on macOS or Alt key
     *  on Windows.
     *
     *  @param[in] window The window whose callback to set.
     *  @param[in] callback The new callback, or `NULL` to remove the currently set
     *  callback.
     *  @return The previously set callback, or `NULL` if no callback was set or the
     *  library had not been [initialized](@ref intro_init).
     *
     *  @callback_signature
     *  @code
     *  void function_name(GLFWwindow* window, unsigned int codepoint)
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [function pointer type](@ref GLFWcharfun).
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref input_char
     *
     *  @since Added in version 2.4.
     *  @glfw3 Added window handle parameter and return value.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwSetCharCallback(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetCharCallback.invokeExact(window, callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the Unicode character with modifiers callback.
     *
     *  This function sets the character with modifiers callback of the specified
     *  window, which is called when a Unicode character is input regardless of what
     *  modifier keys are used.
     *
     *  The character with modifiers callback is intended for implementing custom
     *  Unicode character input.  For regular Unicode text input, see the
     *  [character callback](@ref glfwSetCharCallback).  Like the character
     *  callback, the character with modifiers callback deals with characters and is
     *  keyboard layout dependent.  Characters do not map 1:1 to physical keys, as
     *  a key may produce zero, one or more characters.  If you want to know whether
     *  a specific physical key was pressed or released, see the
     *  [key callback](@ref glfwSetKeyCallback) instead.
     *
     *  @param[in] window The window whose callback to set.
     *  @param[in] callback The new callback, or `NULL` to remove the currently set
     *  callback.
     *  @return The previously set callback, or `NULL` if no callback was set or an
     *  [error](@ref error_handling) occurred.
     *
     *  @callback_signature
     *  @code
     *  void function_name(GLFWwindow* window, unsigned int codepoint, int mods)
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [function pointer type](@ref GLFWcharmodsfun).
     *
     *  @deprecated Scheduled for removal in version 4.0.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref input_char
     *
     *  @since Added in version 3.1.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwSetCharModsCallback(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetCharModsCallback.invokeExact(window, callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the mouse button callback.
     *
     *  This function sets the mouse button callback of the specified window, which
     *  is called when a mouse button is pressed or released.
     *
     *  When a window loses input focus, it will generate synthetic mouse button
     *  release events for all pressed mouse buttons.  You can tell these events
     *  from user-generated events by the fact that the synthetic ones are generated
     *  after the focus loss event has been processed, i.e. after the
     *  [window focus callback](@ref glfwSetWindowFocusCallback) has been called.
     *
     *  @param[in] window The window whose callback to set.
     *  @param[in] callback The new callback, or `NULL` to remove the currently set
     *  callback.
     *  @return The previously set callback, or `NULL` if no callback was set or the
     *  library had not been [initialized](@ref intro_init).
     *
     *  @callback_signature
     *  @code
     *  void function_name(GLFWwindow* window, int button, int action, int mods)
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [function pointer type](@ref GLFWmousebuttonfun).
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref input_mouse_button
     *
     *  @since Added in version 1.0.
     *  @glfw3 Added window handle parameter and return value.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwSetMouseButtonCallback(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetMouseButtonCallback.invokeExact(window, callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the cursor position callback.
     *
     *  This function sets the cursor position callback of the specified window,
     *  which is called when the cursor is moved.  The callback is provided with the
     *  position, in screen coordinates, relative to the upper-left corner of the
     *  content area of the window.
     *
     *  @param[in] window The window whose callback to set.
     *  @param[in] callback The new callback, or `NULL` to remove the currently set
     *  callback.
     *  @return The previously set callback, or `NULL` if no callback was set or the
     *  library had not been [initialized](@ref intro_init).
     *
     *  @callback_signature
     *  @code
     *  void function_name(GLFWwindow* window, double xpos, double ypos);
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [function pointer type](@ref GLFWcursorposfun).
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref cursor_pos
     *
     *  @since Added in version 3.0.  Replaces `glfwSetMousePosCallback`.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwSetCursorPosCallback(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetCursorPosCallback.invokeExact(window, callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the cursor enter/leave callback.
     *
     *  This function sets the cursor boundary crossing callback of the specified
     *  window, which is called when the cursor enters or leaves the content area of
     *  the window.
     *
     *  @param[in] window The window whose callback to set.
     *  @param[in] callback The new callback, or `NULL` to remove the currently set
     *  callback.
     *  @return The previously set callback, or `NULL` if no callback was set or the
     *  library had not been [initialized](@ref intro_init).
     *
     *  @callback_signature
     *  @code
     *  void function_name(GLFWwindow* window, int entered)
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [function pointer type](@ref GLFWcursorenterfun).
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref cursor_enter
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwSetCursorEnterCallback(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetCursorEnterCallback.invokeExact(window, callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the scroll callback.
     *
     *  This function sets the scroll callback of the specified window, which is
     *  called when a scrolling device is used, such as a mouse wheel or scrolling
     *  area of a touchpad.
     *
     *  The scroll callback receives all scrolling input, like that from a mouse
     *  wheel or a touchpad scrolling area.
     *
     *  @param[in] window The window whose callback to set.
     *  @param[in] callback The new scroll callback, or `NULL` to remove the
     *  currently set callback.
     *  @return The previously set callback, or `NULL` if no callback was set or the
     *  library had not been [initialized](@ref intro_init).
     *
     *  @callback_signature
     *  @code
     *  void function_name(GLFWwindow* window, double xoffset, double yoffset)
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [function pointer type](@ref GLFWscrollfun).
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref scrolling
     *
     *  @since Added in version 3.0.  Replaces `glfwSetMouseWheelCallback`.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwSetScrollCallback(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetScrollCallback.invokeExact(window, callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the path drop callback.
     *
     *  This function sets the path drop callback of the specified window, which is
     *  called when one or more dragged paths are dropped on the window.
     *
     *  Because the path array and its strings may have been generated specifically
     *  for that event, they are not guaranteed to be valid after the callback has
     *  returned.  If you wish to use them after the callback returns, you need to
     *  make a deep copy.
     *
     *  @param[in] window The window whose callback to set.
     *  @param[in] callback The new file drop callback, or `NULL` to remove the
     *  currently set callback.
     *  @return The previously set callback, or `NULL` if no callback was set or the
     *  library had not been [initialized](@ref intro_init).
     *
     *  @callback_signature
     *  @code
     *  void function_name(GLFWwindow* window, int path_count, const char* paths[])
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [function pointer type](@ref GLFWdropfun).
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @remark @wayland File drop is currently unimplemented.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref path_drop
     *
     *  @since Added in version 3.1.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwSetDropCallback(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetDropCallback.invokeExact(window, callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns whether the specified joystick is present.
     *
     *  This function returns whether the specified joystick is present.
     *
     *  There is no need to call this function before other functions that accept
     *  a joystick ID, as they all check for presence before performing any other
     *  work.
     *
     *  @param[in] jid The [joystick](@ref joysticks) to query.
     *  @return `GLFW_TRUE` if the joystick is present, or `GLFW_FALSE` otherwise.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref joystick
     *
     *  @since Added in version 3.0.  Replaces `glfwGetJoystickParam`.
     *
     *  @ingroup input
     */
    public static int glfwJoystickPresent(int jid)
    {
        try {return (int)MTD$glfwJoystickPresent.invokeExact(jid);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the values of all axes of the specified joystick.
     *
     *  This function returns the values of all axes of the specified joystick.
     *  Each element in the array is a value between -1.0 and 1.0.
     *
     *  If the specified joystick is not present this function will return `NULL`
     *  but will not generate an error.  This can be used instead of first calling
     *  @ref glfwJoystickPresent.
     *
     *  @param[in] jid The [joystick](@ref joysticks) to query.
     *  @param[out] count Where to store the number of axis values in the returned
     *  array.  This is set to zero if the joystick is not present or an error
     *  occurred.
     *  @return An array of axis values, or `NULL` if the joystick is not present or
     *  an [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
     *
     *  @pointer_lifetime The returned array is allocated and freed by GLFW.  You
     *  should not free it yourself.  It is valid until the specified joystick is
     *  disconnected or the library is terminated.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref joystick_axis
     *
     *  @since Added in version 3.0.  Replaces `glfwGetJoystickPos`.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwGetJoystickAxes(int jid, java.lang.foreign.MemorySegment count)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetJoystickAxes.invokeExact(jid, count);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the state of all buttons of the specified joystick.
     *
     *  This function returns the state of all buttons of the specified joystick.
     *  Each element in the array is either `GLFW_PRESS` or `GLFW_RELEASE`.
     *
     *  For backward compatibility with earlier versions that did not have @ref
     *  glfwGetJoystickHats, the button array also includes all hats, each
     *  represented as four buttons.  The hats are in the same order as returned by
     *  __glfwGetJoystickHats__ and are in the order _up_, _right_, _down_ and
     *  _left_.  To disable these extra buttons, set the @ref
     *  GLFW_JOYSTICK_HAT_BUTTONS init hint before initialization.
     *
     *  If the specified joystick is not present this function will return `NULL`
     *  but will not generate an error.  This can be used instead of first calling
     *  @ref glfwJoystickPresent.
     *
     *  @param[in] jid The [joystick](@ref joysticks) to query.
     *  @param[out] count Where to store the number of button states in the returned
     *  array.  This is set to zero if the joystick is not present or an error
     *  occurred.
     *  @return An array of button states, or `NULL` if the joystick is not present
     *  or an [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
     *
     *  @pointer_lifetime The returned array is allocated and freed by GLFW.  You
     *  should not free it yourself.  It is valid until the specified joystick is
     *  disconnected or the library is terminated.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref joystick_button
     *
     *  @since Added in version 2.2.
     *  @glfw3 Changed to return a dynamic array.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwGetJoystickButtons(int jid, java.lang.foreign.MemorySegment count)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetJoystickButtons.invokeExact(jid, count);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the state of all hats of the specified joystick.
     *
     *  This function returns the state of all hats of the specified joystick.
     *  Each element in the array is one of the following values:
     *
     *  Name                  | Value
     *  ----                  | -----
     *  `GLFW_HAT_CENTERED`   | 0
     *  `GLFW_HAT_UP`         | 1
     *  `GLFW_HAT_RIGHT`      | 2
     *  `GLFW_HAT_DOWN`       | 4
     *  `GLFW_HAT_LEFT`       | 8
     *  `GLFW_HAT_RIGHT_UP`   | `GLFW_HAT_RIGHT` \| `GLFW_HAT_UP`
     *  `GLFW_HAT_RIGHT_DOWN` | `GLFW_HAT_RIGHT` \| `GLFW_HAT_DOWN`
     *  `GLFW_HAT_LEFT_UP`    | `GLFW_HAT_LEFT` \| `GLFW_HAT_UP`
     *  `GLFW_HAT_LEFT_DOWN`  | `GLFW_HAT_LEFT` \| `GLFW_HAT_DOWN`
     *
     *  The diagonal directions are bitwise combinations of the primary (up, right,
     *  down and left) directions and you can test for these individually by ANDing
     *  it with the corresponding direction.
     *
     *  @code
     *  if (hats[2] & GLFW_HAT_RIGHT)
     *  {
     *      // State of hat 2 could be right-up, right or right-down
     *  }
     *  @endcode
     *
     *  If the specified joystick is not present this function will return `NULL`
     *  but will not generate an error.  This can be used instead of first calling
     *  @ref glfwJoystickPresent.
     *
     *  @param[in] jid The [joystick](@ref joysticks) to query.
     *  @param[out] count Where to store the number of hat states in the returned
     *  array.  This is set to zero if the joystick is not present or an error
     *  occurred.
     *  @return An array of hat states, or `NULL` if the joystick is not present
     *  or an [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
     *
     *  @pointer_lifetime The returned array is allocated and freed by GLFW.  You
     *  should not free it yourself.  It is valid until the specified joystick is
     *  disconnected, this function is called again for that joystick or the library
     *  is terminated.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref joystick_hat
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwGetJoystickHats(int jid, java.lang.foreign.MemorySegment count)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetJoystickHats.invokeExact(jid, count);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the name of the specified joystick.
     *
     *  This function returns the name, encoded as UTF-8, of the specified joystick.
     *  The returned string is allocated and freed by GLFW.  You should not free it
     *  yourself.
     *
     *  If the specified joystick is not present this function will return `NULL`
     *  but will not generate an error.  This can be used instead of first calling
     *  @ref glfwJoystickPresent.
     *
     *  @param[in] jid The [joystick](@ref joysticks) to query.
     *  @return The UTF-8 encoded name of the joystick, or `NULL` if the joystick
     *  is not present or an [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
     *
     *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You
     *  should not free it yourself.  It is valid until the specified joystick is
     *  disconnected or the library is terminated.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref joystick_name
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwGetJoystickName(int jid)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetJoystickName.invokeExact(jid);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the SDL compatible GUID of the specified joystick.
     *
     *  This function returns the SDL compatible GUID, as a UTF-8 encoded
     *  hexadecimal string, of the specified joystick.  The returned string is
     *  allocated and freed by GLFW.  You should not free it yourself.
     *
     *  The GUID is what connects a joystick to a gamepad mapping.  A connected
     *  joystick will always have a GUID even if there is no gamepad mapping
     *  assigned to it.
     *
     *  If the specified joystick is not present this function will return `NULL`
     *  but will not generate an error.  This can be used instead of first calling
     *  @ref glfwJoystickPresent.
     *
     *  The GUID uses the format introduced in SDL 2.0.5.  This GUID tries to
     *  uniquely identify the make and model of a joystick but does not identify
     *  a specific unit, e.g. all wired Xbox 360 controllers will have the same
     *  GUID on that platform.  The GUID for a unit may vary between platforms
     *  depending on what hardware information the platform specific APIs provide.
     *
     *  @param[in] jid The [joystick](@ref joysticks) to query.
     *  @return The UTF-8 encoded GUID of the joystick, or `NULL` if the joystick
     *  is not present or an [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
     *
     *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You
     *  should not free it yourself.  It is valid until the specified joystick is
     *  disconnected or the library is terminated.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref gamepad
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwGetJoystickGUID(int jid)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetJoystickGUID.invokeExact(jid);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the user pointer of the specified joystick.
     *
     *  This function sets the user-defined pointer of the specified joystick.  The
     *  current value is retained until the joystick is disconnected.  The initial
     *  value is `NULL`.
     *
     *  This function may be called from the joystick callback, even for a joystick
     *  that is being disconnected.
     *
     *  @param[in] jid The joystick whose pointer to set.
     *  @param[in] pointer The new value.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function may be called from any thread.  Access is not
     *  synchronized.
     *
     *  @sa @ref joystick_userptr
     *  @sa @ref glfwGetJoystickUserPointer
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup input
     */
    public static void glfwSetJoystickUserPointer(int jid, java.lang.foreign.MemorySegment pointer)
    {
        try {MTD$glfwSetJoystickUserPointer.invokeExact(jid, pointer);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the user pointer of the specified joystick.
     *
     *  This function returns the current value of the user-defined pointer of the
     *  specified joystick.  The initial value is `NULL`.
     *
     *  This function may be called from the joystick callback, even for a joystick
     *  that is being disconnected.
     *
     *  @param[in] jid The joystick whose pointer to return.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function may be called from any thread.  Access is not
     *  synchronized.
     *
     *  @sa @ref joystick_userptr
     *  @sa @ref glfwSetJoystickUserPointer
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwGetJoystickUserPointer(int jid)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetJoystickUserPointer.invokeExact(jid);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns whether the specified joystick has a gamepad mapping.
     *
     *  This function returns whether the specified joystick is both present and has
     *  a gamepad mapping.
     *
     *  If the specified joystick is present but does not have a gamepad mapping
     *  this function will return `GLFW_FALSE` but will not generate an error.  Call
     *  @ref glfwJoystickPresent to check if a joystick is present regardless of
     *  whether it has a mapping.
     *
     *  @param[in] jid The [joystick](@ref joysticks) to query.
     *  @return `GLFW_TRUE` if a joystick is both present and has a gamepad mapping,
     *  or `GLFW_FALSE` otherwise.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_INVALID_ENUM.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref gamepad
     *  @sa @ref glfwGetGamepadState
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup input
     */
    public static int glfwJoystickIsGamepad(int jid)
    {
        try {return (int)MTD$glfwJoystickIsGamepad.invokeExact(jid);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the joystick configuration callback.
     *
     *  This function sets the joystick configuration callback, or removes the
     *  currently set callback.  This is called when a joystick is connected to or
     *  disconnected from the system.
     *
     *  For joystick connection and disconnection events to be delivered on all
     *  platforms, you need to call one of the [event processing](@ref events)
     *  functions.  Joystick disconnection may also be detected and the callback
     *  called by joystick functions.  The function will then return whatever it
     *  returns if the joystick is not present.
     *
     *  @param[in] callback The new callback, or `NULL` to remove the currently set
     *  callback.
     *  @return The previously set callback, or `NULL` if no callback was set or the
     *  library had not been [initialized](@ref intro_init).
     *
     *  @callback_signature
     *  @code
     *  void function_name(int jid, int event)
     *  @endcode
     *  For more information about the callback parameters, see the
     *  [function pointer type](@ref GLFWjoystickfun).
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref joystick_event
     *
     *  @since Added in version 3.2.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwSetJoystickCallback(java.lang.foreign.MemorySegment callback)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwSetJoystickCallback.invokeExact(callback);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Adds the specified SDL_GameControllerDB gamepad mappings.
     *
     *  This function parses the specified ASCII encoded string and updates the
     *  internal list with any gamepad mappings it finds.  This string may
     *  contain either a single gamepad mapping or many mappings separated by
     *  newlines.  The parser supports the full format of the `gamecontrollerdb.txt`
     *  source file including empty lines and comments.
     *
     *  See @ref gamepad_mapping for a description of the format.
     *
     *  If there is already a gamepad mapping for a given GUID in the internal list,
     *  it will be replaced by the one passed to this function.  If the library is
     *  terminated and re-initialized the internal list will revert to the built-in
     *  default.
     *
     *  @param[in] string The string containing the gamepad mappings.
     *  @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_INVALID_VALUE.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref gamepad
     *  @sa @ref glfwJoystickIsGamepad
     *  @sa @ref glfwGetGamepadName
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup input
     */
    public static int glfwUpdateGamepadMappings(java.lang.foreign.MemorySegment string)
    {
        try {return (int)MTD$glfwUpdateGamepadMappings.invokeExact(string);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the human-readable gamepad name for the specified joystick.
     *
     *  This function returns the human-readable name of the gamepad from the
     *  gamepad mapping assigned to the specified joystick.
     *
     *  If the specified joystick is not present or does not have a gamepad mapping
     *  this function will return `NULL` but will not generate an error.  Call
     *  @ref glfwJoystickPresent to check whether it is present regardless of
     *  whether it has a mapping.
     *
     *  @param[in] jid The [joystick](@ref joysticks) to query.
     *  @return The UTF-8 encoded name of the gamepad, or `NULL` if the
     *  joystick is not present, does not have a mapping or an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref GLFW_INVALID_ENUM.
     *
     *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You
     *  should not free it yourself.  It is valid until the specified joystick is
     *  disconnected, the gamepad mappings are updated or the library is terminated.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref gamepad
     *  @sa @ref glfwJoystickIsGamepad
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwGetGamepadName(int jid)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetGamepadName.invokeExact(jid);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Retrieves the state of the specified joystick remapped as a gamepad.
     *
     *  This function retrieves the state of the specified joystick remapped to
     *  an Xbox-like gamepad.
     *
     *  If the specified joystick is not present or does not have a gamepad mapping
     *  this function will return `GLFW_FALSE` but will not generate an error.  Call
     *  @ref glfwJoystickPresent to check whether it is present regardless of
     *  whether it has a mapping.
     *
     *  The Guide button may not be available for input as it is often hooked by the
     *  system or the Steam client.
     *
     *  Not all devices have all the buttons or axes provided by @ref
     *  GLFWgamepadstate.  Unavailable buttons and axes will always report
     *  `GLFW_RELEASE` and 0.0 respectively.
     *
     *  @param[in] jid The [joystick](@ref joysticks) to query.
     *  @param[out] state The gamepad input state of the joystick.
     *  @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if no joystick is
     *  connected, it has no gamepad mapping or an [error](@ref error_handling)
     *  occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_INVALID_ENUM.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref gamepad
     *  @sa @ref glfwUpdateGamepadMappings
     *  @sa @ref glfwJoystickIsGamepad
     *
     *  @since Added in version 3.3.
     *
     *  @ingroup input
     */
    public static int glfwGetGamepadState(int jid, java.lang.foreign.MemorySegment state)
    {
        try {return (int)MTD$glfwGetGamepadState.invokeExact(jid, state);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the clipboard to the specified string.
     *
     *  This function sets the system clipboard to the specified, UTF-8 encoded
     *  string.
     *
     *  @param[in] window Deprecated.  Any valid window or `NULL`.
     *  @param[in] string A UTF-8 encoded string.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @pointer_lifetime The specified string is copied before this function
     *  returns.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref clipboard
     *  @sa @ref glfwGetClipboardString
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup input
     */
    public static void glfwSetClipboardString(java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment string)
    {
        try {MTD$glfwSetClipboardString.invokeExact(window, string);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the contents of the clipboard as a string.
     *
     *  This function returns the contents of the system clipboard, if it contains
     *  or is convertible to a UTF-8 encoded string.  If the clipboard is empty or
     *  if its contents cannot be converted, `NULL` is returned and a @ref
     *  GLFW_FORMAT_UNAVAILABLE error is generated.
     *
     *  @param[in] window Deprecated.  Any valid window or `NULL`.
     *  @return The contents of the clipboard as a UTF-8 encoded string, or `NULL`
     *  if an [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_FORMAT_UNAVAILABLE and @ref GLFW_PLATFORM_ERROR.
     *
     *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You
     *  should not free it yourself.  It is valid until the next call to @ref
     *  glfwGetClipboardString or @ref glfwSetClipboardString, or until the library
     *  is terminated.
     *
     *  @thread_safety This function must only be called from the main thread.
     *
     *  @sa @ref clipboard
     *  @sa @ref glfwSetClipboardString
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup input
     */
    public static java.lang.foreign.MemorySegment glfwGetClipboardString(java.lang.foreign.MemorySegment window)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetClipboardString.invokeExact(window);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the GLFW time.
     *
     *  This function returns the current GLFW time, in seconds.  Unless the time
     *  has been set using @ref glfwSetTime it measures time elapsed since GLFW was
     *  initialized.
     *
     *  This function and @ref glfwSetTime are helper functions on top of @ref
     *  glfwGetTimerFrequency and @ref glfwGetTimerValue.
     *
     *  The resolution of the timer is system dependent, but is usually on the order
     *  of a few micro- or nanoseconds.  It uses the highest-resolution monotonic
     *  time source on each supported platform.
     *
     *  @return The current time, in seconds, or zero if an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function may be called from any thread.  Reading and
     *  writing of the internal base time is not atomic, so it needs to be
     *  externally synchronized with calls to @ref glfwSetTime.
     *
     *  @sa @ref time
     *
     *  @since Added in version 1.0.
     *
     *  @ingroup input
     */
    public static double glfwGetTime()
    {
        try {return (double)MTD$glfwGetTime.invokeExact();}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the GLFW time.
     *
     *  This function sets the current GLFW time, in seconds.  The value must be
     *  a positive finite number less than or equal to 18446744073.0, which is
     *  approximately 584.5 years.
     *
     *  This function and @ref glfwGetTime are helper functions on top of @ref
     *  glfwGetTimerFrequency and @ref glfwGetTimerValue.
     *
     *  @param[in] time The new value, in seconds.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_INVALID_VALUE.
     *
     *  @remark The upper limit of GLFW time is calculated as
     *  floor((2<sup>64</sup> - 1) / 10<sup>9</sup>) and is due to implementations
     *  storing nanoseconds in 64 bits.  The limit may be increased in the future.
     *
     *  @thread_safety This function may be called from any thread.  Reading and
     *  writing of the internal base time is not atomic, so it needs to be
     *  externally synchronized with calls to @ref glfwGetTime.
     *
     *  @sa @ref time
     *
     *  @since Added in version 2.2.
     *
     *  @ingroup input
     */
    public static void glfwSetTime(double time)
    {
        try {MTD$glfwSetTime.invokeExact(time);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the current value of the raw timer.
     *
     *  This function returns the current value of the raw timer, measured in
     *  1&nbsp;/&nbsp;frequency seconds.  To get the frequency, call @ref
     *  glfwGetTimerFrequency.
     *
     *  @return The value of the timer, or zero if an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function may be called from any thread.
     *
     *  @sa @ref time
     *  @sa @ref glfwGetTimerFrequency
     *
     *  @since Added in version 3.2.
     *
     *  @ingroup input
     */
    public static long glfwGetTimerValue()
    {
        try {return (long)MTD$glfwGetTimerValue.invokeExact();}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the frequency, in Hz, of the raw timer.
     *
     *  This function returns the frequency, in Hz, of the raw timer.
     *
     *  @return The frequency of the timer, in Hz, or zero if an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function may be called from any thread.
     *
     *  @sa @ref time
     *  @sa @ref glfwGetTimerValue
     *
     *  @since Added in version 3.2.
     *
     *  @ingroup input
     */
    public static long glfwGetTimerFrequency()
    {
        try {return (long)MTD$glfwGetTimerFrequency.invokeExact();}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Makes the context of the specified window current for the calling
     *  thread.
     *
     *  This function makes the OpenGL or OpenGL ES context of the specified window
     *  current on the calling thread.  It can also detach the current context from
     *  the calling thread without making a new one current by passing in `NULL`.
     *
     *  A context must only be made current on a single thread at a time and each
     *  thread can have only a single current context at a time.  Making a context
     *  current detaches any previously current context on the calling thread.
     *
     *  When moving a context between threads, you must detach it (make it
     *  non-current) on the old thread before making it current on the new one.
     *
     *  By default, making a context non-current implicitly forces a pipeline flush.
     *  On machines that support `GL_KHR_context_flush_control`, you can control
     *  whether a context performs this flush by setting the
     *  [GLFW_CONTEXT_RELEASE_BEHAVIOR](@ref GLFW_CONTEXT_RELEASE_BEHAVIOR_hint)
     *  hint.
     *
     *  The specified window must have an OpenGL or OpenGL ES context.  Specifying
     *  a window without a context will generate a @ref GLFW_NO_WINDOW_CONTEXT
     *  error.
     *
     *  @param[in] window The window whose context to make current, or `NULL` to
     *  detach the current context.
     *
     *  @remarks If the previously current context was created via a different
     *  context creation API than the one passed to this function, GLFW will still
     *  detach the previous one from its API before making the new one current.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_NO_WINDOW_CONTEXT and @ref GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function may be called from any thread.
     *
     *  @sa @ref context_current
     *  @sa @ref glfwGetCurrentContext
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup context
     */
    public static void glfwMakeContextCurrent(java.lang.foreign.MemorySegment window)
    {
        try {MTD$glfwMakeContextCurrent.invokeExact(window);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the window whose context is current on the calling thread.
     *
     *  This function returns the window whose OpenGL or OpenGL ES context is
     *  current on the calling thread.
     *
     *  @return The window whose context is current, or `NULL` if no window's
     *  context is current.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function may be called from any thread.
     *
     *  @sa @ref context_current
     *  @sa @ref glfwMakeContextCurrent
     *
     *  @since Added in version 3.0.
     *
     *  @ingroup context
     */
    public static java.lang.foreign.MemorySegment glfwGetCurrentContext()
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetCurrentContext.invokeExact();}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Swaps the front and back buffers of the specified window.
     *
     *  This function swaps the front and back buffers of the specified window when
     *  rendering with OpenGL or OpenGL ES.  If the swap interval is greater than
     *  zero, the GPU driver waits the specified number of screen updates before
     *  swapping the buffers.
     *
     *  The specified window must have an OpenGL or OpenGL ES context.  Specifying
     *  a window without a context will generate a @ref GLFW_NO_WINDOW_CONTEXT
     *  error.
     *
     *  This function does not apply to Vulkan.  If you are rendering with Vulkan,
     *  see `vkQueuePresentKHR` instead.
     *
     *  @param[in] window The window whose buffers to swap.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_NO_WINDOW_CONTEXT and @ref GLFW_PLATFORM_ERROR.
     *
     *  @remark __EGL:__ The context of the specified window must be current on the
     *  calling thread.
     *
     *  @thread_safety This function may be called from any thread.
     *
     *  @sa @ref buffer_swap
     *  @sa @ref glfwSwapInterval
     *
     *  @since Added in version 1.0.
     *  @glfw3 Added window handle parameter.
     *
     *  @ingroup window
     */
    public static void glfwSwapBuffers(java.lang.foreign.MemorySegment window)
    {
        try {MTD$glfwSwapBuffers.invokeExact(window);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Sets the swap interval for the current context.
     *
     *  This function sets the swap interval for the current OpenGL or OpenGL ES
     *  context, i.e. the number of screen updates to wait from the time @ref
     *  glfwSwapBuffers was called before swapping the buffers and returning.  This
     *  is sometimes called _vertical synchronization_, _vertical retrace
     *  synchronization_ or just _vsync_.
     *
     *  A context that supports either of the `WGL_EXT_swap_control_tear` and
     *  `GLX_EXT_swap_control_tear` extensions also accepts _negative_ swap
     *  intervals, which allows the driver to swap immediately even if a frame
     *  arrives a little bit late.  You can check for these extensions with @ref
     *  glfwExtensionSupported.
     *
     *  A context must be current on the calling thread.  Calling this function
     *  without a current context will cause a @ref GLFW_NO_CURRENT_CONTEXT error.
     *
     *  This function does not apply to Vulkan.  If you are rendering with Vulkan,
     *  see the present mode of your swapchain instead.
     *
     *  @param[in] interval The minimum number of screen updates to wait for
     *  until the buffers are swapped by @ref glfwSwapBuffers.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_NO_CURRENT_CONTEXT and @ref GLFW_PLATFORM_ERROR.
     *
     *  @remark This function is not called during context creation, leaving the
     *  swap interval set to whatever is the default on that platform.  This is done
     *  because some swap interval extensions used by GLFW do not allow the swap
     *  interval to be reset to zero once it has been set to a non-zero value.
     *
     *  @remark Some GPU drivers do not honor the requested swap interval, either
     *  because of a user setting that overrides the application's request or due to
     *  bugs in the driver.
     *
     *  @thread_safety This function may be called from any thread.
     *
     *  @sa @ref buffer_swap
     *  @sa @ref glfwSwapBuffers
     *
     *  @since Added in version 1.0.
     *
     *  @ingroup context
     */
    public static void glfwSwapInterval(int interval)
    {
        try {MTD$glfwSwapInterval.invokeExact(interval);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns whether the specified extension is available.
     *
     *  This function returns whether the specified
     *  [API extension](@ref context_glext) is supported by the current OpenGL or
     *  OpenGL ES context.  It searches both for client API extension and context
     *  creation API extensions.
     *
     *  A context must be current on the calling thread.  Calling this function
     *  without a current context will cause a @ref GLFW_NO_CURRENT_CONTEXT error.
     *
     *  As this functions retrieves and searches one or more extension strings each
     *  call, it is recommended that you cache its results if it is going to be used
     *  frequently.  The extension strings will not change during the lifetime of
     *  a context, so there is no danger in doing this.
     *
     *  This function does not apply to Vulkan.  If you are using Vulkan, see @ref
     *  glfwGetRequiredInstanceExtensions, `vkEnumerateInstanceExtensionProperties`
     *  and `vkEnumerateDeviceExtensionProperties` instead.
     *
     *  @param[in] extension The ASCII encoded name of the extension.
     *  @return `GLFW_TRUE` if the extension is available, or `GLFW_FALSE`
     *  otherwise.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_NO_CURRENT_CONTEXT, @ref GLFW_INVALID_VALUE and @ref
     *  GLFW_PLATFORM_ERROR.
     *
     *  @thread_safety This function may be called from any thread.
     *
     *  @sa @ref context_glext
     *  @sa @ref glfwGetProcAddress
     *
     *  @since Added in version 1.0.
     *
     *  @ingroup context
     */
    public static int glfwExtensionSupported(java.lang.foreign.MemorySegment extension)
    {
        try {return (int)MTD$glfwExtensionSupported.invokeExact(extension);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the address of the specified function for the current
     *  context.
     *
     *  This function returns the address of the specified OpenGL or OpenGL ES
     *  [core or extension function](@ref context_glext), if it is supported
     *  by the current context.
     *
     *  A context must be current on the calling thread.  Calling this function
     *  without a current context will cause a @ref GLFW_NO_CURRENT_CONTEXT error.
     *
     *  This function does not apply to Vulkan.  If you are rendering with Vulkan,
     *  see @ref glfwGetInstanceProcAddress, `vkGetInstanceProcAddr` and
     *  `vkGetDeviceProcAddr` instead.
     *
     *  @param[in] procname The ASCII encoded name of the function.
     *  @return The address of the function, or `NULL` if an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_NO_CURRENT_CONTEXT and @ref GLFW_PLATFORM_ERROR.
     *
     *  @remark The address of a given function is not guaranteed to be the same
     *  between contexts.
     *
     *  @remark This function may return a non-`NULL` address despite the
     *  associated version or extension not being available.  Always check the
     *  context version or extension string first.
     *
     *  @pointer_lifetime The returned function pointer is valid until the context
     *  is destroyed or the library is terminated.
     *
     *  @thread_safety This function may be called from any thread.
     *
     *  @sa @ref context_glext
     *  @sa @ref glfwExtensionSupported
     *
     *  @since Added in version 1.0.
     *
     *  @ingroup context
     */
    public static java.lang.foreign.MemorySegment glfwGetProcAddress(java.lang.foreign.MemorySegment procname)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetProcAddress.invokeExact(procname);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns whether the Vulkan loader and an ICD have been found.
     *
     *  This function returns whether the Vulkan loader and any minimally functional
     *  ICD have been found.
     *
     *  The availability of a Vulkan loader and even an ICD does not by itself guarantee that
     *  surface creation or even instance creation is possible.  Call @ref
     *  glfwGetRequiredInstanceExtensions to check whether the extensions necessary for Vulkan
     *  surface creation are available and @ref glfwGetPhysicalDevicePresentationSupport to
     *  check whether a queue family of a physical device supports image presentation.
     *
     *  @return `GLFW_TRUE` if Vulkan is minimally available, or `GLFW_FALSE`
     *  otherwise.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
     *
     *  @thread_safety This function may be called from any thread.
     *
     *  @sa @ref vulkan_support
     *
     *  @since Added in version 3.2.
     *
     *  @ingroup vulkan
     */
    public static int glfwVulkanSupported()
    {
        try {return (int)MTD$glfwVulkanSupported.invokeExact();}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the Vulkan instance extensions required by GLFW.
     *
     *  This function returns an array of names of Vulkan instance extensions required
     *  by GLFW for creating Vulkan surfaces for GLFW windows.  If successful, the
     *  list will always contain `VK_KHR_surface`, so if you don't require any
     *  additional extensions you can pass this list directly to the
     *  `VkInstanceCreateInfo` struct.
     *
     *  If Vulkan is not available on the machine, this function returns `NULL` and
     *  generates a @ref GLFW_API_UNAVAILABLE error.  Call @ref glfwVulkanSupported
     *  to check whether Vulkan is at least minimally available.
     *
     *  If Vulkan is available but no set of extensions allowing window surface
     *  creation was found, this function returns `NULL`.  You may still use Vulkan
     *  for off-screen rendering and compute work.
     *
     *  @param[out] count Where to store the number of extensions in the returned
     *  array.  This is set to zero if an error occurred.
     *  @return An array of ASCII encoded extension names, or `NULL` if an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_API_UNAVAILABLE.
     *
     *  @remark Additional extensions may be required by future versions of GLFW.
     *  You should check if any extensions you wish to enable are already in the
     *  returned array, as it is an error to specify an extension more than once in
     *  the `VkInstanceCreateInfo` struct.
     *
     *  @pointer_lifetime The returned array is allocated and freed by GLFW.  You
     *  should not free it yourself.  It is guaranteed to be valid only until the
     *  library is terminated.
     *
     *  @thread_safety This function may be called from any thread.
     *
     *  @sa @ref vulkan_ext
     *  @sa @ref glfwCreateWindowSurface
     *
     *  @since Added in version 3.2.
     *
     *  @ingroup vulkan
     */
    public static java.lang.foreign.MemorySegment glfwGetRequiredInstanceExtensions(java.lang.foreign.MemorySegment count)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetRequiredInstanceExtensions.invokeExact(count);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns the address of the specified Vulkan instance function.
     *
     *  This function returns the address of the specified Vulkan core or extension
     *  function for the specified instance.  If instance is set to `NULL` it can
     *  return any function exported from the Vulkan loader, including at least the
     *  following functions:
     *
     *  - `vkEnumerateInstanceExtensionProperties`
     *  - `vkEnumerateInstanceLayerProperties`
     *  - `vkCreateInstance`
     *  - `vkGetInstanceProcAddr`
     *
     *  If Vulkan is not available on the machine, this function returns `NULL` and
     *  generates a @ref GLFW_API_UNAVAILABLE error.  Call @ref glfwVulkanSupported
     *  to check whether Vulkan is at least minimally available.
     *
     *  This function is equivalent to calling `vkGetInstanceProcAddr` with
     *  a platform-specific query of the Vulkan loader as a fallback.
     *
     *  @param[in] instance The Vulkan instance to query, or `NULL` to retrieve
     *  functions related to instance creation.
     *  @param[in] procname The ASCII encoded name of the function.
     *  @return The address of the function, or `NULL` if an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
     *  GLFW_API_UNAVAILABLE.
     *
     *  @pointer_lifetime The returned function pointer is valid until the library
     *  is terminated.
     *
     *  @thread_safety This function may be called from any thread.
     *
     *  @sa @ref vulkan_proc
     *
     *  @since Added in version 3.2.
     *
     *  @ingroup vulkan
     */
    public static java.lang.foreign.MemorySegment glfwGetInstanceProcAddress(java.lang.foreign.MemorySegment instance, java.lang.foreign.MemorySegment procname)
    {
        try {return (java.lang.foreign.MemorySegment)MTD$glfwGetInstanceProcAddress.invokeExact(instance, procname);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Returns whether the specified queue family can present images.
     *
     *  This function returns whether the specified queue family of the specified
     *  physical device supports presentation to the platform GLFW was built for.
     *
     *  If Vulkan or the required window surface creation instance extensions are
     *  not available on the machine, or if the specified instance was not created
     *  with the required extensions, this function returns `GLFW_FALSE` and
     *  generates a @ref GLFW_API_UNAVAILABLE error.  Call @ref glfwVulkanSupported
     *  to check whether Vulkan is at least minimally available and @ref
     *  glfwGetRequiredInstanceExtensions to check what instance extensions are
     *  required.
     *
     *  @param[in] instance The instance that the physical device belongs to.
     *  @param[in] device The physical device that the queue family belongs to.
     *  @param[in] queuefamily The index of the queue family to query.
     *  @return `GLFW_TRUE` if the queue family supports presentation, or
     *  `GLFW_FALSE` otherwise.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_API_UNAVAILABLE and @ref GLFW_PLATFORM_ERROR.
     *
     *  @remark @macos This function currently always returns `GLFW_TRUE`, as the
     *  `VK_MVK_macos_surface` and `VK_EXT_metal_surface` extensions do not provide
     *  a `vkGetPhysicalDevice*PresentationSupport` type function.
     *
     *  @thread_safety This function may be called from any thread.  For
     *  synchronization details of Vulkan objects, see the Vulkan specification.
     *
     *  @sa @ref vulkan_present
     *
     *  @since Added in version 3.2.
     *
     *  @ingroup vulkan
     */
    public static int glfwGetPhysicalDevicePresentationSupport(java.lang.foreign.MemorySegment instance, java.lang.foreign.MemorySegment device, int queuefamily)
    {
        try {return (int)MTD$glfwGetPhysicalDevicePresentationSupport.invokeExact(instance, device, queuefamily);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    /*! @brief Creates a Vulkan surface for the specified window.
     *
     *  This function creates a Vulkan surface for the specified window.
     *
     *  If the Vulkan loader or at least one minimally functional ICD were not found,
     *  this function returns `VK_ERROR_INITIALIZATION_FAILED` and generates a @ref
     *  GLFW_API_UNAVAILABLE error.  Call @ref glfwVulkanSupported to check whether
     *  Vulkan is at least minimally available.
     *
     *  If the required window surface creation instance extensions are not
     *  available or if the specified instance was not created with these extensions
     *  enabled, this function returns `VK_ERROR_EXTENSION_NOT_PRESENT` and
     *  generates a @ref GLFW_API_UNAVAILABLE error.  Call @ref
     *  glfwGetRequiredInstanceExtensions to check what instance extensions are
     *  required.
     *
     *  The window surface cannot be shared with another API so the window must
     *  have been created with the [client api hint](@ref GLFW_CLIENT_API_attrib)
     *  set to `GLFW_NO_API` otherwise it generates a @ref GLFW_INVALID_VALUE error
     *  and returns `VK_ERROR_NATIVE_WINDOW_IN_USE_KHR`.
     *
     *  The window surface must be destroyed before the specified Vulkan instance.
     *  It is the responsibility of the caller to destroy the window surface.  GLFW
     *  does not destroy it for you.  Call `vkDestroySurfaceKHR` to destroy the
     *  surface.
     *
     *  @param[in] instance The Vulkan instance to create the surface in.
     *  @param[in] window The window to create the surface for.
     *  @param[in] allocator The allocator to use, or `NULL` to use the default
     *  allocator.
     *  @param[out] surface Where to store the handle of the surface.  This is set
     *  to `VK_NULL_HANDLE` if an error occurred.
     *  @return `VK_SUCCESS` if successful, or a Vulkan error code if an
     *  [error](@ref error_handling) occurred.
     *
     *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
     *  GLFW_API_UNAVAILABLE, @ref GLFW_PLATFORM_ERROR and @ref GLFW_INVALID_VALUE
     *
     *  @remark If an error occurs before the creation call is made, GLFW returns
     *  the Vulkan error code most appropriate for the error.  Appropriate use of
     *  @ref glfwVulkanSupported and @ref glfwGetRequiredInstanceExtensions should
     *  eliminate almost all occurrences of these errors.
     *
     *  @remark @macos GLFW prefers the `VK_EXT_metal_surface` extension, with the
     *  `VK_MVK_macos_surface` extension as a fallback.  The name of the selected
     *  extension, if any, is included in the array returned by @ref
     *  glfwGetRequiredInstanceExtensions.
     *
     *  @remark @macos This function creates and sets a `CAMetalLayer` instance for
     *  the window content view, which is required for MoltenVK to function.
     *
     *  @thread_safety This function may be called from any thread.  For
     *  synchronization details of Vulkan objects, see the Vulkan specification.
     *
     *  @sa @ref vulkan_surface
     *  @sa @ref glfwGetRequiredInstanceExtensions
     *
     *  @since Added in version 3.2.
     *
     *  @ingroup vulkan
     */
    public static int glfwCreateWindowSurface(java.lang.foreign.MemorySegment instance, java.lang.foreign.MemorySegment window, java.lang.foreign.MemorySegment allocator, java.lang.foreign.MemorySegment surface)
    {
        try {return (int)MTD$glfwCreateWindowSurface.invokeExact(instance, window, allocator, surface);}
        catch (java.lang.Throwable _) {throw new java.lang.AssertionError();}
    }

    static
    {
        java.lang.System.loadLibrary("glfw3");
        gSystemLinker = java.lang.foreign.Linker.nativeLinker();
        gLibLookup = name -> java.lang.foreign.SymbolLookup.loaderLookup().find(name).or(() -> gSystemLinker.defaultLookup().find(name));

        MTD_ADDRESS$glfwInit = gLibLookup.find("glfwInit").orElseThrow();
        MTD$glfwInit = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwInit, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwTerminate = gLibLookup.find("glfwTerminate").orElseThrow();
        MTD$glfwTerminate = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwTerminate, java.lang.foreign.FunctionDescriptor.ofVoid());
        MTD_ADDRESS$glfwInitHint = gLibLookup.find("glfwInitHint").orElseThrow();
        MTD$glfwInitHint = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwInitHint, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwGetVersion = gLibLookup.find("glfwGetVersion").orElseThrow();
        MTD$glfwGetVersion = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetVersion, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetVersionString = gLibLookup.find("glfwGetVersionString").orElseThrow();
        MTD$glfwGetVersionString = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetVersionString, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetError = gLibLookup.find("glfwGetError").orElseThrow();
        MTD$glfwGetError = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetError, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetErrorCallback = gLibLookup.find("glfwSetErrorCallback").orElseThrow();
        MTD$glfwSetErrorCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetErrorCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetMonitors = gLibLookup.find("glfwGetMonitors").orElseThrow();
        MTD$glfwGetMonitors = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetMonitors, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetPrimaryMonitor = gLibLookup.find("glfwGetPrimaryMonitor").orElseThrow();
        MTD$glfwGetPrimaryMonitor = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetPrimaryMonitor, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetMonitorPos = gLibLookup.find("glfwGetMonitorPos").orElseThrow();
        MTD$glfwGetMonitorPos = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetMonitorPos, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetMonitorWorkarea = gLibLookup.find("glfwGetMonitorWorkarea").orElseThrow();
        MTD$glfwGetMonitorWorkarea = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetMonitorWorkarea, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetMonitorPhysicalSize = gLibLookup.find("glfwGetMonitorPhysicalSize").orElseThrow();
        MTD$glfwGetMonitorPhysicalSize = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetMonitorPhysicalSize, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetMonitorContentScale = gLibLookup.find("glfwGetMonitorContentScale").orElseThrow();
        MTD$glfwGetMonitorContentScale = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetMonitorContentScale, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetMonitorName = gLibLookup.find("glfwGetMonitorName").orElseThrow();
        MTD$glfwGetMonitorName = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetMonitorName, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetMonitorUserPointer = gLibLookup.find("glfwSetMonitorUserPointer").orElseThrow();
        MTD$glfwSetMonitorUserPointer = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetMonitorUserPointer, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetMonitorUserPointer = gLibLookup.find("glfwGetMonitorUserPointer").orElseThrow();
        MTD$glfwGetMonitorUserPointer = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetMonitorUserPointer, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetMonitorCallback = gLibLookup.find("glfwSetMonitorCallback").orElseThrow();
        MTD$glfwSetMonitorCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetMonitorCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetVideoModes = gLibLookup.find("glfwGetVideoModes").orElseThrow();
        MTD$glfwGetVideoModes = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetVideoModes, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetVideoMode = gLibLookup.find("glfwGetVideoMode").orElseThrow();
        MTD$glfwGetVideoMode = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetVideoMode, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetGamma = gLibLookup.find("glfwSetGamma").orElseThrow();
        MTD$glfwSetGamma = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetGamma, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_FLOAT));
        MTD_ADDRESS$glfwGetGammaRamp = gLibLookup.find("glfwGetGammaRamp").orElseThrow();
        MTD$glfwGetGammaRamp = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetGammaRamp, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetGammaRamp = gLibLookup.find("glfwSetGammaRamp").orElseThrow();
        MTD$glfwSetGammaRamp = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetGammaRamp, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwDefaultWindowHints = gLibLookup.find("glfwDefaultWindowHints").orElseThrow();
        MTD$glfwDefaultWindowHints = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwDefaultWindowHints, java.lang.foreign.FunctionDescriptor.ofVoid());
        MTD_ADDRESS$glfwWindowHint = gLibLookup.find("glfwWindowHint").orElseThrow();
        MTD$glfwWindowHint = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwWindowHint, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwWindowHintString = gLibLookup.find("glfwWindowHintString").orElseThrow();
        MTD$glfwWindowHintString = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwWindowHintString, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwCreateWindow = gLibLookup.find("glfwCreateWindow").orElseThrow();
        MTD$glfwCreateWindow = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwCreateWindow, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwDestroyWindow = gLibLookup.find("glfwDestroyWindow").orElseThrow();
        MTD$glfwDestroyWindow = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwDestroyWindow, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwWindowShouldClose = gLibLookup.find("glfwWindowShouldClose").orElseThrow();
        MTD$glfwWindowShouldClose = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwWindowShouldClose, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetWindowShouldClose = gLibLookup.find("glfwSetWindowShouldClose").orElseThrow();
        MTD$glfwSetWindowShouldClose = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetWindowShouldClose, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwSetWindowTitle = gLibLookup.find("glfwSetWindowTitle").orElseThrow();
        MTD$glfwSetWindowTitle = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetWindowTitle, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetWindowIcon = gLibLookup.find("glfwSetWindowIcon").orElseThrow();
        MTD$glfwSetWindowIcon = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetWindowIcon, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetWindowPos = gLibLookup.find("glfwGetWindowPos").orElseThrow();
        MTD$glfwGetWindowPos = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetWindowPos, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetWindowPos = gLibLookup.find("glfwSetWindowPos").orElseThrow();
        MTD$glfwSetWindowPos = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetWindowPos, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwGetWindowSize = gLibLookup.find("glfwGetWindowSize").orElseThrow();
        MTD$glfwGetWindowSize = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetWindowSize, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetWindowSizeLimits = gLibLookup.find("glfwSetWindowSizeLimits").orElseThrow();
        MTD$glfwSetWindowSizeLimits = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetWindowSizeLimits, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwSetWindowAspectRatio = gLibLookup.find("glfwSetWindowAspectRatio").orElseThrow();
        MTD$glfwSetWindowAspectRatio = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetWindowAspectRatio, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwSetWindowSize = gLibLookup.find("glfwSetWindowSize").orElseThrow();
        MTD$glfwSetWindowSize = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetWindowSize, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwGetFramebufferSize = gLibLookup.find("glfwGetFramebufferSize").orElseThrow();
        MTD$glfwGetFramebufferSize = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetFramebufferSize, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetWindowFrameSize = gLibLookup.find("glfwGetWindowFrameSize").orElseThrow();
        MTD$glfwGetWindowFrameSize = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetWindowFrameSize, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetWindowContentScale = gLibLookup.find("glfwGetWindowContentScale").orElseThrow();
        MTD$glfwGetWindowContentScale = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetWindowContentScale, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetWindowOpacity = gLibLookup.find("glfwGetWindowOpacity").orElseThrow();
        MTD$glfwGetWindowOpacity = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetWindowOpacity, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_FLOAT, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetWindowOpacity = gLibLookup.find("glfwSetWindowOpacity").orElseThrow();
        MTD$glfwSetWindowOpacity = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetWindowOpacity, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_FLOAT));
        MTD_ADDRESS$glfwIconifyWindow = gLibLookup.find("glfwIconifyWindow").orElseThrow();
        MTD$glfwIconifyWindow = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwIconifyWindow, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwRestoreWindow = gLibLookup.find("glfwRestoreWindow").orElseThrow();
        MTD$glfwRestoreWindow = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwRestoreWindow, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwMaximizeWindow = gLibLookup.find("glfwMaximizeWindow").orElseThrow();
        MTD$glfwMaximizeWindow = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwMaximizeWindow, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwShowWindow = gLibLookup.find("glfwShowWindow").orElseThrow();
        MTD$glfwShowWindow = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwShowWindow, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwHideWindow = gLibLookup.find("glfwHideWindow").orElseThrow();
        MTD$glfwHideWindow = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwHideWindow, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwFocusWindow = gLibLookup.find("glfwFocusWindow").orElseThrow();
        MTD$glfwFocusWindow = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwFocusWindow, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwRequestWindowAttention = gLibLookup.find("glfwRequestWindowAttention").orElseThrow();
        MTD$glfwRequestWindowAttention = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwRequestWindowAttention, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetWindowMonitor = gLibLookup.find("glfwGetWindowMonitor").orElseThrow();
        MTD$glfwGetWindowMonitor = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetWindowMonitor, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetWindowMonitor = gLibLookup.find("glfwSetWindowMonitor").orElseThrow();
        MTD$glfwSetWindowMonitor = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetWindowMonitor, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwGetWindowAttrib = gLibLookup.find("glfwGetWindowAttrib").orElseThrow();
        MTD$glfwGetWindowAttrib = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetWindowAttrib, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwSetWindowAttrib = gLibLookup.find("glfwSetWindowAttrib").orElseThrow();
        MTD$glfwSetWindowAttrib = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetWindowAttrib, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwSetWindowUserPointer = gLibLookup.find("glfwSetWindowUserPointer").orElseThrow();
        MTD$glfwSetWindowUserPointer = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetWindowUserPointer, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetWindowUserPointer = gLibLookup.find("glfwGetWindowUserPointer").orElseThrow();
        MTD$glfwGetWindowUserPointer = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetWindowUserPointer, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetWindowPosCallback = gLibLookup.find("glfwSetWindowPosCallback").orElseThrow();
        MTD$glfwSetWindowPosCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetWindowPosCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetWindowSizeCallback = gLibLookup.find("glfwSetWindowSizeCallback").orElseThrow();
        MTD$glfwSetWindowSizeCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetWindowSizeCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetWindowCloseCallback = gLibLookup.find("glfwSetWindowCloseCallback").orElseThrow();
        MTD$glfwSetWindowCloseCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetWindowCloseCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetWindowRefreshCallback = gLibLookup.find("glfwSetWindowRefreshCallback").orElseThrow();
        MTD$glfwSetWindowRefreshCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetWindowRefreshCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetWindowFocusCallback = gLibLookup.find("glfwSetWindowFocusCallback").orElseThrow();
        MTD$glfwSetWindowFocusCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetWindowFocusCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetWindowIconifyCallback = gLibLookup.find("glfwSetWindowIconifyCallback").orElseThrow();
        MTD$glfwSetWindowIconifyCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetWindowIconifyCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetWindowMaximizeCallback = gLibLookup.find("glfwSetWindowMaximizeCallback").orElseThrow();
        MTD$glfwSetWindowMaximizeCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetWindowMaximizeCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetFramebufferSizeCallback = gLibLookup.find("glfwSetFramebufferSizeCallback").orElseThrow();
        MTD$glfwSetFramebufferSizeCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetFramebufferSizeCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetWindowContentScaleCallback = gLibLookup.find("glfwSetWindowContentScaleCallback").orElseThrow();
        MTD$glfwSetWindowContentScaleCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetWindowContentScaleCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwPollEvents = gLibLookup.find("glfwPollEvents").orElseThrow();
        MTD$glfwPollEvents = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwPollEvents, java.lang.foreign.FunctionDescriptor.ofVoid());
        MTD_ADDRESS$glfwWaitEvents = gLibLookup.find("glfwWaitEvents").orElseThrow();
        MTD$glfwWaitEvents = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwWaitEvents, java.lang.foreign.FunctionDescriptor.ofVoid());
        MTD_ADDRESS$glfwWaitEventsTimeout = gLibLookup.find("glfwWaitEventsTimeout").orElseThrow();
        MTD$glfwWaitEventsTimeout = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwWaitEventsTimeout, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.JAVA_DOUBLE));
        MTD_ADDRESS$glfwPostEmptyEvent = gLibLookup.find("glfwPostEmptyEvent").orElseThrow();
        MTD$glfwPostEmptyEvent = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwPostEmptyEvent, java.lang.foreign.FunctionDescriptor.ofVoid());
        MTD_ADDRESS$glfwGetInputMode = gLibLookup.find("glfwGetInputMode").orElseThrow();
        MTD$glfwGetInputMode = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetInputMode, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwSetInputMode = gLibLookup.find("glfwSetInputMode").orElseThrow();
        MTD$glfwSetInputMode = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetInputMode, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwRawMouseMotionSupported = gLibLookup.find("glfwRawMouseMotionSupported").orElseThrow();
        MTD$glfwRawMouseMotionSupported = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwRawMouseMotionSupported, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwGetKeyName = gLibLookup.find("glfwGetKeyName").orElseThrow();
        MTD$glfwGetKeyName = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetKeyName, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwGetKeyScancode = gLibLookup.find("glfwGetKeyScancode").orElseThrow();
        MTD$glfwGetKeyScancode = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetKeyScancode, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwGetKey = gLibLookup.find("glfwGetKey").orElseThrow();
        MTD$glfwGetKey = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetKey, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwGetMouseButton = gLibLookup.find("glfwGetMouseButton").orElseThrow();
        MTD$glfwGetMouseButton = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetMouseButton, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwGetCursorPos = gLibLookup.find("glfwGetCursorPos").orElseThrow();
        MTD$glfwGetCursorPos = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetCursorPos, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetCursorPos = gLibLookup.find("glfwSetCursorPos").orElseThrow();
        MTD$glfwSetCursorPos = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetCursorPos, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_DOUBLE, java.lang.foreign.ValueLayout.JAVA_DOUBLE));
        MTD_ADDRESS$glfwCreateCursor = gLibLookup.find("glfwCreateCursor").orElseThrow();
        MTD$glfwCreateCursor = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwCreateCursor, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwCreateStandardCursor = gLibLookup.find("glfwCreateStandardCursor").orElseThrow();
        MTD$glfwCreateStandardCursor = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwCreateStandardCursor, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwDestroyCursor = gLibLookup.find("glfwDestroyCursor").orElseThrow();
        MTD$glfwDestroyCursor = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwDestroyCursor, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetCursor = gLibLookup.find("glfwSetCursor").orElseThrow();
        MTD$glfwSetCursor = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetCursor, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetKeyCallback = gLibLookup.find("glfwSetKeyCallback").orElseThrow();
        MTD$glfwSetKeyCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetKeyCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetCharCallback = gLibLookup.find("glfwSetCharCallback").orElseThrow();
        MTD$glfwSetCharCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetCharCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetCharModsCallback = gLibLookup.find("glfwSetCharModsCallback").orElseThrow();
        MTD$glfwSetCharModsCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetCharModsCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetMouseButtonCallback = gLibLookup.find("glfwSetMouseButtonCallback").orElseThrow();
        MTD$glfwSetMouseButtonCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetMouseButtonCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetCursorPosCallback = gLibLookup.find("glfwSetCursorPosCallback").orElseThrow();
        MTD$glfwSetCursorPosCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetCursorPosCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetCursorEnterCallback = gLibLookup.find("glfwSetCursorEnterCallback").orElseThrow();
        MTD$glfwSetCursorEnterCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetCursorEnterCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetScrollCallback = gLibLookup.find("glfwSetScrollCallback").orElseThrow();
        MTD$glfwSetScrollCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetScrollCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetDropCallback = gLibLookup.find("glfwSetDropCallback").orElseThrow();
        MTD$glfwSetDropCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetDropCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwJoystickPresent = gLibLookup.find("glfwJoystickPresent").orElseThrow();
        MTD$glfwJoystickPresent = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwJoystickPresent, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwGetJoystickAxes = gLibLookup.find("glfwGetJoystickAxes").orElseThrow();
        MTD$glfwGetJoystickAxes = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetJoystickAxes, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetJoystickButtons = gLibLookup.find("glfwGetJoystickButtons").orElseThrow();
        MTD$glfwGetJoystickButtons = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetJoystickButtons, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetJoystickHats = gLibLookup.find("glfwGetJoystickHats").orElseThrow();
        MTD$glfwGetJoystickHats = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetJoystickHats, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetJoystickName = gLibLookup.find("glfwGetJoystickName").orElseThrow();
        MTD$glfwGetJoystickName = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetJoystickName, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwGetJoystickGUID = gLibLookup.find("glfwGetJoystickGUID").orElseThrow();
        MTD$glfwGetJoystickGUID = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetJoystickGUID, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwSetJoystickUserPointer = gLibLookup.find("glfwSetJoystickUserPointer").orElseThrow();
        MTD$glfwSetJoystickUserPointer = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetJoystickUserPointer, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetJoystickUserPointer = gLibLookup.find("glfwGetJoystickUserPointer").orElseThrow();
        MTD$glfwGetJoystickUserPointer = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetJoystickUserPointer, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwJoystickIsGamepad = gLibLookup.find("glfwJoystickIsGamepad").orElseThrow();
        MTD$glfwJoystickIsGamepad = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwJoystickIsGamepad, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwSetJoystickCallback = gLibLookup.find("glfwSetJoystickCallback").orElseThrow();
        MTD$glfwSetJoystickCallback = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetJoystickCallback, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwUpdateGamepadMappings = gLibLookup.find("glfwUpdateGamepadMappings").orElseThrow();
        MTD$glfwUpdateGamepadMappings = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwUpdateGamepadMappings, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetGamepadName = gLibLookup.find("glfwGetGamepadName").orElseThrow();
        MTD$glfwGetGamepadName = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetGamepadName, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwGetGamepadState = gLibLookup.find("glfwGetGamepadState").orElseThrow();
        MTD$glfwGetGamepadState = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetGamepadState, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSetClipboardString = gLibLookup.find("glfwSetClipboardString").orElseThrow();
        MTD$glfwSetClipboardString = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetClipboardString, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetClipboardString = gLibLookup.find("glfwGetClipboardString").orElseThrow();
        MTD$glfwGetClipboardString = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetClipboardString, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetTime = gLibLookup.find("glfwGetTime").orElseThrow();
        MTD$glfwGetTime = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetTime, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_DOUBLE));
        MTD_ADDRESS$glfwSetTime = gLibLookup.find("glfwSetTime").orElseThrow();
        MTD$glfwSetTime = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSetTime, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.JAVA_DOUBLE));
        MTD_ADDRESS$glfwGetTimerValue = gLibLookup.find("glfwGetTimerValue").orElseThrow();
        MTD$glfwGetTimerValue = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetTimerValue, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_LONG));
        MTD_ADDRESS$glfwGetTimerFrequency = gLibLookup.find("glfwGetTimerFrequency").orElseThrow();
        MTD$glfwGetTimerFrequency = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetTimerFrequency, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_LONG));
        MTD_ADDRESS$glfwMakeContextCurrent = gLibLookup.find("glfwMakeContextCurrent").orElseThrow();
        MTD$glfwMakeContextCurrent = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwMakeContextCurrent, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetCurrentContext = gLibLookup.find("glfwGetCurrentContext").orElseThrow();
        MTD$glfwGetCurrentContext = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetCurrentContext, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSwapBuffers = gLibLookup.find("glfwSwapBuffers").orElseThrow();
        MTD$glfwSwapBuffers = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSwapBuffers, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwSwapInterval = gLibLookup.find("glfwSwapInterval").orElseThrow();
        MTD$glfwSwapInterval = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwSwapInterval, java.lang.foreign.FunctionDescriptor.ofVoid(java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwExtensionSupported = gLibLookup.find("glfwExtensionSupported").orElseThrow();
        MTD$glfwExtensionSupported = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwExtensionSupported, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetProcAddress = gLibLookup.find("glfwGetProcAddress").orElseThrow();
        MTD$glfwGetProcAddress = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetProcAddress, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwVulkanSupported = gLibLookup.find("glfwVulkanSupported").orElseThrow();
        MTD$glfwVulkanSupported = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwVulkanSupported, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwGetRequiredInstanceExtensions = gLibLookup.find("glfwGetRequiredInstanceExtensions").orElseThrow();
        MTD$glfwGetRequiredInstanceExtensions = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetRequiredInstanceExtensions, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetInstanceProcAddress = gLibLookup.find("glfwGetInstanceProcAddress").orElseThrow();
        MTD$glfwGetInstanceProcAddress = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetInstanceProcAddress, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
        MTD_ADDRESS$glfwGetPhysicalDevicePresentationSupport = gLibLookup.find("glfwGetPhysicalDevicePresentationSupport").orElseThrow();
        MTD$glfwGetPhysicalDevicePresentationSupport = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwGetPhysicalDevicePresentationSupport, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.JAVA_INT));
        MTD_ADDRESS$glfwCreateWindowSurface = gLibLookup.find("glfwCreateWindowSurface").orElseThrow();
        MTD$glfwCreateWindowSurface = gSystemLinker.downcallHandle(MTD_ADDRESS$glfwCreateWindowSurface, java.lang.foreign.FunctionDescriptor.of(java.lang.foreign.ValueLayout.JAVA_INT, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS, java.lang.foreign.ValueLayout.ADDRESS));
    }
}
